/*
 * Copyright (c) 2016-2022 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChild, EventEmitter, HostBinding, Inject, Input, Optional, Output, SkipSelf, } from '@angular/core';
import { ClrCommonStringsService } from '../../utils/i18n/common-strings.service';
import { UNIQUE_ID, UNIQUE_ID_PROVIDER } from '../../utils/id-generator/id-generator.service';
import { ClrStackViewLabel } from './stack-view-custom-tags';
export class ClrStackBlock {
    /*
     * This would be more efficient with @ContentChildren, with the parent ClrStackBlock
     * querying for children StackBlocks, but this feature is not available when downgrading
     * the component for Angular 1.
     */
    constructor(parent, uniqueId, commonStrings) {
        this.parent = parent;
        this.uniqueId = uniqueId;
        this.commonStrings = commonStrings;
        this.expanded = false;
        this.expandedChange = new EventEmitter(false);
        this.expandable = false;
        this.focused = false;
        this._changedChildren = 0;
        this._fullyInitialized = false;
        this._changed = false;
        if (parent) {
            parent.addChild();
        }
    }
    get getChangedValue() {
        return this._changed || (this._changedChildren > 0 && !this.expanded);
    }
    set setChangedValue(value) {
        this._changed = value;
        if (this.parent && this._fullyInitialized) {
            if (value) {
                this.parent._changedChildren++;
            }
            else {
                this.parent._changedChildren--;
            }
        }
    }
    get labelledById() {
        return this.stackBlockTitle.id;
    }
    get headingLevel() {
        if (this.ariaLevel) {
            return this.ariaLevel + '';
        }
        return this.parent ? '4' : '3';
    }
    ngOnInit() {
        // in order to access the parent ClrStackBlock's properties,
        // the child ClrStackBlock has to be fully initialized at first.
        this._fullyInitialized = true;
    }
    addChild() {
        this.expandable = true;
    }
    toggleExpand() {
        if (this.expandable) {
            this.expanded = !this.expanded;
            this.expandedChange.emit(this.expanded);
        }
    }
    get caretDirection() {
        return this.expanded ? 'down' : 'right';
    }
    get role() {
        return this.expandable ? 'button' : null;
    }
    get tabIndex() {
        return this.expandable ? '0' : null;
    }
    get onStackLabelFocus() {
        return this.expandable && !this.expanded && this.focused;
    }
    get ariaExpanded() {
        if (!this.expandable) {
            return null;
        }
        else {
            return this.expanded ? 'true' : 'false';
        }
    }
    getStackChildrenId() {
        return this.expanded ? `clr-stack-children-${this.uniqueId}` : null;
    }
}
ClrStackBlock.decorators = [
    { type: Component, args: [{
                selector: 'clr-stack-block',
                template: `
    <div
      class="stack-block-label"
      (click)="toggleExpand()"
      (keyup.enter)="toggleExpand()"
      (keyup.space)="toggleExpand()"
      (focus)="focused = true"
      (blur)="focused = false"
      [id]="uniqueId"
      [attr.role]="role"
      [attr.tabindex]="tabIndex"
      [attr.aria-expanded]="ariaExpanded"
      [attr.aria-controls]="getStackChildrenId()"
    >
      <cds-icon shape="angle" class="stack-block-caret" *ngIf="expandable" [attr.direction]="caretDirection"></cds-icon>
      <span class="clr-sr-only" *ngIf="getChangedValue">{{ commonStrings.keys.stackViewChanged }}</span>
      <div class="stack-view-key">
        <!-- This structure changed to fix #3567 and the a11y request was to move away from dl's -->
        <!-- I added the key class to update css targets for the original component style -->
        <ng-content select="clr-stack-label"></ng-content>
      </div>
      <div class="stack-block-content">
        <ng-content></ng-content>
      </div>
    </div>

    <clr-expandable-animation [clrExpandTrigger]="expanded" class="stack-children">
      <div
        [style.height]="expanded ? 'auto' : 0"
        role="region"
        *ngIf="expanded"
        [attr.id]="getStackChildrenId()"
        [attr.aria-labelledby]="labelledById"
      >
        <ng-content select="clr-stack-block"></ng-content>
      </div>
    </clr-expandable-animation>
  `,
                // Make sure the host has the proper class for styling purposes
                host: {
                    '[class.stack-block]': 'true',
                    '[attr.role]': '"heading"',
                    '[attr.aria-level]': 'headingLevel',
                },
                providers: [UNIQUE_ID_PROVIDER],
                styles: [`
      :host {
        display: block;
      }
    `]
            },] }
];
ClrStackBlock.ctorParameters = () => [
    { type: ClrStackBlock, decorators: [{ type: SkipSelf }, { type: Optional }] },
    { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] },
    { type: ClrCommonStringsService }
];
ClrStackBlock.propDecorators = {
    expanded: [{ type: HostBinding, args: ['class.stack-block-expanded',] }, { type: Input, args: ['clrSbExpanded',] }],
    expandedChange: [{ type: Output, args: ['clrSbExpandedChange',] }],
    expandable: [{ type: HostBinding, args: ['class.stack-block-expandable',] }, { type: Input, args: ['clrSbExpandable',] }],
    stackBlockTitle: [{ type: ContentChild, args: [ClrStackViewLabel,] }],
    getChangedValue: [{ type: HostBinding, args: ['class.stack-block-changed',] }],
    setChangedValue: [{ type: Input, args: ['clrSbNotifyChange',] }],
    ariaLevel: [{ type: Input, args: ['clrStackViewLevel',] }],
    ariaSetsize: [{ type: Input, args: ['clrStackViewSetsize',] }],
    ariaPosinset: [{ type: Input, args: ['clrStackViewPosinset',] }],
    onStackLabelFocus: [{ type: HostBinding, args: ['class.on-focus',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2stYmxvY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyL3NyYy9kYXRhL3N0YWNrLXZpZXcvc3RhY2stYmxvY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFDTCxTQUFTLEVBQ1QsWUFBWSxFQUNaLFlBQVksRUFDWixXQUFXLEVBQ1gsTUFBTSxFQUNOLEtBQUssRUFFTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLFFBQVEsR0FDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUNsRixPQUFPLEVBQUUsU0FBUyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sK0NBQStDLENBQUM7QUFDOUYsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUEwRDdELE1BQU0sT0FBTyxhQUFhO0lBc0V4Qjs7OztPQUlHO0lBQ0gsWUFHVSxNQUFxQixFQUNILFFBQWdCLEVBQ25DLGFBQXNDO1FBRnJDLFdBQU0sR0FBTixNQUFNLENBQWU7UUFDSCxhQUFRLEdBQVIsUUFBUSxDQUFRO1FBQ25DLGtCQUFhLEdBQWIsYUFBYSxDQUF5QjtRQTdFL0MsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNjLG1CQUFjLEdBQTBCLElBQUksWUFBWSxDQUFVLEtBQUssQ0FBQyxDQUFDO1FBR3hHLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFLbkIsWUFBTyxHQUFHLEtBQUssQ0FBQztRQUNSLHFCQUFnQixHQUFHLENBQUMsQ0FBQztRQUNyQixzQkFBaUIsR0FBRyxLQUFLLENBQUM7UUFDMUIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQW1FdkIsSUFBSSxNQUFNLEVBQUU7WUFDVixNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDbkI7SUFDSCxDQUFDO0lBcEVELElBQ0ksZUFBZTtRQUNqQixPQUFPLElBQUksQ0FB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QixDQUFDO3lCQVo3Qjs7OztLQUlDO2FBU0o7OztZQStFbUIsYUFBYSx1QkFGNUIsUUFBUSxZQUNSLFFBQVE7eUNBRVIsTUFBTSxTQUFDLFNBQVM7WUEzSVosdUJBQXVCOzs7dUJBNkQ3QixXQUFXLFNBQUMsNEJBQTRCLGNBQ3hDLEtBQUssU0FBQyxlQUFlOzZCQUVyQixNQUFNLFNBQUMscUJBQXFCO3lCQUM1QixXQUFXLFNBQUMsOEJBQThCLGNBQzFDLEtBQUssU0FBQyxpQkFBaUI7OEJBR3ZCLFlBQVksU0FBQyxpQkFBaUI7OEJBUTlCLFdBQVcsU0FBQywyQkFBMkI7OEJBS3ZDLEtBQUssU0FBQyxtQkFBbUI7d0JBNEJ6QixLQUFLLFNBQUMsbUJBQW1COzBCQVN6QixLQUFLLFNBQUMscUJBQXFCOzJCQVMzQixLQUFLLFNBQUMsc0JBQXNCO2dDQWdENUIsV0FBVyxTQUFDLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMiBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdEJpbmRpbmcsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgU2tpcFNlbGYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVU5JUVVFX0lELCBVTklRVUVfSURfUFJPVklERVIgfSBmcm9tICcuLi8uLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3TGFiZWwgfSBmcm9tICcuL3N0YWNrLXZpZXctY3VzdG9tLXRhZ3MnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3RhY2stYmxvY2snLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwic3RhY2stYmxvY2stbGFiZWxcIlxuICAgICAgKGNsaWNrKT1cInRvZ2dsZUV4cGFuZCgpXCJcbiAgICAgIChrZXl1cC5lbnRlcik9XCJ0b2dnbGVFeHBhbmQoKVwiXG4gICAgICAoa2V5dXAuc3BhY2UpPVwidG9nZ2xlRXhwYW5kKClcIlxuICAgICAgKGZvY3VzKT1cImZvY3VzZWQgPSB0cnVlXCJcbiAgICAgIChibHVyKT1cImZvY3VzZWQgPSBmYWxzZVwiXG4gICAgICBbaWRdPVwidW5pcXVlSWRcIlxuICAgICAgW2F0dHIucm9sZV09XCJyb2xlXCJcbiAgICAgIFthdHRyLnRhYmluZGV4XT1cInRhYkluZGV4XCJcbiAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiYXJpYUV4cGFuZGVkXCJcbiAgICAgIFthdHRyLmFyaWEtY29udHJvbHNdPVwiZ2V0U3RhY2tDaGlsZHJlbklkKClcIlxuICAgID5cbiAgICAgIDxjZHMtaWNvbiBzaGFwZT1cImFuZ2xlXCIgY2xhc3M9XCJzdGFjay1ibG9jay1jYXJldFwiICpuZ0lmPVwiZXhwYW5kYWJsZVwiIFthdHRyLmRpcmVjdGlvbl09XCJjYXJldERpcmVjdGlvblwiPjwvY2RzLWljb24+XG4gICAgICA8c3BhbiBjbGFzcz1cImNsci1zci1vbmx5XCIgKm5nSWY9XCJnZXRDaGFuZ2VkVmFsdWVcIj57eyBjb21tb25TdHJpbmdzLmtleXMuc3RhY2tWaWV3Q2hhbmdlZCB9fTwvc3Bhbj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzdGFjay12aWV3LWtleVwiPlxuICAgICAgICA8IS0tIFRoaXMgc3RydWN0dXJlIGNoYW5nZWQgdG8gZml4ICMzNTY3IGFuZCB0aGUgYTExeSByZXF1ZXN0IHdhcyB0byBtb3ZlIGF3YXkgZnJvbSBkbCdzIC0tPlxuICAgICAgICA8IS0tIEkgYWRkZWQgdGhlIGtleSBjbGFzcyB0byB1cGRhdGUgY3NzIHRhcmdldHMgZm9yIHRoZSBvcmlnaW5hbCBjb21wb25lbnQgc3R5bGUgLS0+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1zdGFjay1sYWJlbFwiPjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInN0YWNrLWJsb2NrLWNvbnRlbnRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8Y2xyLWV4cGFuZGFibGUtYW5pbWF0aW9uIFtjbHJFeHBhbmRUcmlnZ2VyXT1cImV4cGFuZGVkXCIgY2xhc3M9XCJzdGFjay1jaGlsZHJlblwiPlxuICAgICAgPGRpdlxuICAgICAgICBbc3R5bGUuaGVpZ2h0XT1cImV4cGFuZGVkID8gJ2F1dG8nIDogMFwiXG4gICAgICAgIHJvbGU9XCJyZWdpb25cIlxuICAgICAgICAqbmdJZj1cImV4cGFuZGVkXCJcbiAgICAgICAgW2F0dHIuaWRdPVwiZ2V0U3RhY2tDaGlsZHJlbklkKClcIlxuICAgICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwibGFiZWxsZWRCeUlkXCJcbiAgICAgID5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXN0YWNrLWJsb2NrXCI+PC9uZy1jb250ZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9jbHItZXhwYW5kYWJsZS1hbmltYXRpb24+XG4gIGAsXG4gIC8vIEN1c3RvbSBlbGVtZW50cyBhcmUgaW5saW5lIGJ5IGRlZmF1bHRcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICBgLFxuICBdLFxuICAvLyBNYWtlIHN1cmUgdGhlIGhvc3QgaGFzIHRoZSBwcm9wZXIgY2xhc3MgZm9yIHN0eWxpbmcgcHVycG9zZXNcbiAgaG9zdDoge1xuICAgICdbY2xhc3Muc3RhY2stYmxvY2tdJzogJ3RydWUnLFxuICAgICdbYXR0ci5yb2xlXSc6ICdcImhlYWRpbmdcIicsXG4gICAgJ1thdHRyLmFyaWEtbGV2ZWxdJzogJ2hlYWRpbmdMZXZlbCcsXG4gIH0sXG4gIHByb3ZpZGVyczogW1VOSVFVRV9JRF9QUk9WSURFUl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrQmxvY2sgaW1wbGVtZW50cyBPbkluaXQge1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnN0YWNrLWJsb2NrLWV4cGFuZGVkJylcbiAgQElucHV0KCdjbHJTYkV4cGFuZGVkJylcbiAgZXhwYW5kZWQgPSBmYWxzZTtcbiAgQE91dHB1dCgnY2xyU2JFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zdGFjay1ibG9jay1leHBhbmRhYmxlJylcbiAgQElucHV0KCdjbHJTYkV4cGFuZGFibGUnKVxuICBleHBhbmRhYmxlID0gZmFsc2U7XG5cbiAgQENvbnRlbnRDaGlsZChDbHJTdGFja1ZpZXdMYWJlbClcbiAgc3RhY2tCbG9ja1RpdGxlOiBhbnk7XG5cbiAgZm9jdXNlZCA9IGZhbHNlO1xuICBwcml2YXRlIF9jaGFuZ2VkQ2hpbGRyZW4gPSAwO1xuICBwcml2YXRlIF9mdWxseUluaXRpYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgX2NoYW5nZWQgPSBmYWxzZTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnN0YWNrLWJsb2NrLWNoYW5nZWQnKVxuICBnZXQgZ2V0Q2hhbmdlZFZhbHVlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkIHx8ICh0aGlzLl9jaGFuZ2VkQ2hpbGRyZW4gPiAwICYmICF0aGlzLmV4cGFuZGVkKTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyU2JOb3RpZnlDaGFuZ2UnKVxuICBzZXQgc2V0Q2hhbmdlZFZhbHVlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY2hhbmdlZCA9IHZhbHVlO1xuXG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMuX2Z1bGx5SW5pdGlhbGl6ZWQpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5fY2hhbmdlZENoaWxkcmVuKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudC5fY2hhbmdlZENoaWxkcmVuLS07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxhYmVsbGVkQnlJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja0Jsb2NrVGl0bGUuaWQ7XG4gIH1cblxuICBnZXQgaGVhZGluZ0xldmVsKCkge1xuICAgIGlmICh0aGlzLmFyaWFMZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJpYUxldmVsICsgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gJzQnIDogJzMnO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHRoIG9mIHRoZSBzdGFjayB2aWV3IHN0YXJ0aW5nIGZyb20gMSBmb3IgZmlyc3QgbGV2ZWxcbiAgICovXG4gIEBJbnB1dCgnY2xyU3RhY2tWaWV3TGV2ZWwnKSBhcmlhTGV2ZWw6IG51bWJlcjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gYSBnaXZlbiBncm91cFxuICAgKiAtIHJlbW92ZWQgcGVyIGExMXkgKHNlZTogVlBBVC01OTIpXG4gICAqIC0gcmVtYWlucyBoZXJlIGFuZCB1bnVzZWQgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlIHRvIHRoZSBwdWJsaWMgQVBJXG4gICAqIC0gcmVtb3ZlIGluIHYxNFxuICAgKi9cbiAgQElucHV0KCdjbHJTdGFja1ZpZXdTZXRzaXplJykgYXJpYVNldHNpemU6IG51bWJlcjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSByb3cgaW5zaWRlIHRoZSBncm91cGVkIGJ5IGxldmVsIHJvd3NcbiAgICogLSByZW1vdmVkIHBlciBhMTF5IChzZWU6IFZQQVQtNTkyKVxuICAgKiAtIHJlbWFpbnMgaGVyZSBhbmQgdW51c2VkIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgcHVibGljIEFQSVxuICAgKiAtIHJlbW92ZSBpbiB2MTRcbiAgICovXG4gIEBJbnB1dCgnY2xyU3RhY2tWaWV3UG9zaW5zZXQnKSBhcmlhUG9zaW5zZXQ6IG51bWJlcjtcblxuICAvKlxuICAgKiBUaGlzIHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IHdpdGggQENvbnRlbnRDaGlsZHJlbiwgd2l0aCB0aGUgcGFyZW50IENsclN0YWNrQmxvY2tcbiAgICogcXVlcnlpbmcgZm9yIGNoaWxkcmVuIFN0YWNrQmxvY2tzLCBidXQgdGhpcyBmZWF0dXJlIGlzIG5vdCBhdmFpbGFibGUgd2hlbiBkb3duZ3JhZGluZ1xuICAgKiB0aGUgY29tcG9uZW50IGZvciBBbmd1bGFyIDEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBAU2tpcFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHJpdmF0ZSBwYXJlbnQ6IENsclN0YWNrQmxvY2ssXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyB1bmlxdWVJZDogc3RyaW5nLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzU2VydmljZVxuICApIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuYWRkQ2hpbGQoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAvLyBpbiBvcmRlciB0byBhY2Nlc3MgdGhlIHBhcmVudCBDbHJTdGFja0Jsb2NrJ3MgcHJvcGVydGllcyxcbiAgICAvLyB0aGUgY2hpbGQgQ2xyU3RhY2tCbG9jayBoYXMgdG8gYmUgZnVsbHkgaW5pdGlhbGl6ZWQgYXQgZmlyc3QuXG4gICAgdGhpcy5fZnVsbHlJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhZGRDaGlsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmV4cGFuZGFibGUgPSB0cnVlO1xuICB9XG5cbiAgdG9nZ2xlRXhwYW5kKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGUpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICB9XG4gIH1cblxuICBnZXQgY2FyZXREaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRlZCA/ICdkb3duJyA6ICdyaWdodCc7XG4gIH1cblxuICBnZXQgcm9sZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGUgPyAnYnV0dG9uJyA6IG51bGw7XG4gIH1cblxuICBnZXQgdGFiSW5kZXgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlID8gJzAnIDogbnVsbDtcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnY2xhc3Mub24tZm9jdXMnKVxuICBnZXQgb25TdGFja0xhYmVsRm9jdXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kYWJsZSAmJiAhdGhpcy5leHBhbmRlZCAmJiB0aGlzLmZvY3VzZWQ7XG4gIH1cblxuICBnZXQgYXJpYUV4cGFuZGVkKCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmV4cGFuZGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBhbmRlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhY2tDaGlsZHJlbklkKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGVkID8gYGNsci1zdGFjay1jaGlsZHJlbi0ke3RoaXMudW5pcXVlSWR9YCA6IG51bGw7XG4gIH1cbn1cbiJdfQ==