/*
 * Copyright (c) 2016-2022 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, Inject, ContentChild, ElementRef, NgZone, PLATFORM_ID, ViewChild } from '@angular/core';
import { UNIQUE_ID, UNIQUE_ID_PROVIDER } from '../../utils/id-generator/id-generator.service';
import { ClrAxis } from '../../utils/popover/enums/axis.enum';
import { ClrAlignment } from '../../utils/popover/enums/alignment.enum';
import { ClrSide } from '../../utils/popover/enums/side.enum';
import { ClrPopoverEventsService } from '../../utils/popover/providers/popover-events.service';
import { ClrPopoverPositionService } from '../../utils/popover/providers/popover-position.service';
import { ClrPopoverToggleService } from '../../utils/popover/providers/popover-toggle.service';
import { ClrCommonStringsService } from '../../utils/i18n/common-strings.service';
import { ColumnsService } from './providers/columns.service';
import { DatagridColumnChanges } from './enums/column-changes.enum';
import { ClrDatagridColumnToggleTitle } from './datagrid-column-toggle-title';
import { ClrDatagridColumnToggleButton } from './datagrid-column-toggle-button';
/** @deprecated since 2.0, remove in 3.0 */
export class ClrDatagridColumnToggle {
    constructor(commonStrings, columnsService, columnSwitchId, platformId, zone, popoverId) {
        this.commonStrings = commonStrings;
        this.columnsService = columnsService;
        this.columnSwitchId = columnSwitchId;
        this.platformId = platformId;
        this.zone = zone;
        this.popoverId = popoverId;
        // Smart Popover
        this.smartPosition = {
            axis: ClrAxis.VERTICAL,
            side: ClrSide.BEFORE,
            anchor: ClrAlignment.START,
            content: ClrAlignment.START,
        };
    }
    get allColumnsVisible() {
        return this._allColumnsVisible;
    }
    set allColumnsVisible(value) {
        this._allColumnsVisible = value;
    }
    get hideableColumnStates() {
        const hideables = this.columnsService.columns.filter(column => column.value.hideable);
        return hideables.map(column => column.value);
    }
    get hasOnlyOneVisibleColumn() {
        const nbNonHideableColumns = this.columnsService.columns.length - this.hideableColumnStates.length;
        // this should only return true when there is no non-hideable columns.
        return (nbNonHideableColumns === 0 && this.hideableColumnStates.filter(columnState => !columnState.hidden).length === 1);
    }
    toggleColumnState(columnState, event) {
        const columnToToggle = this.columnsService.columns.filter(column => column.value === columnState)[0];
        this.columnsService.emitStateChange(columnToToggle, {
            hidden: event,
            changes: [DatagridColumnChanges.HIDDEN],
        });
    }
    toggleSwitchPanel() {
        this.openState = !this.openState;
    }
    allColumnsSelected() {
        this.allSelectedElement.nativeElement.focus();
    }
    // Without tracking the checkboxes get rerendered on model update, which leads
    // to loss of focus after checkbox toggle.
    trackByFn(index) {
        return index;
    }
}
ClrDatagridColumnToggle.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-column-toggle',
                template: `
    <button
      role="button"
      type="button"
      class="btn btn-sm btn-link column-toggle--action"
      clrPopoverAnchor
      clrPopoverOpenCloseButton
      [attr.aria-controls]="popoverId"
      [attr.aria-owns]="popoverId"
      [attr.title]="commonStrings.keys.pickColumns"
    >
      <cds-icon shape="view-columns" aria-hidden="true" [attr.title]="commonStrings.keys.pickColumns"></cds-icon>
    </button>
    <div
      class="column-switch"
      role="dialog"
      [attr.aria-label]="commonStrings.keys.showColumnsMenuDescription"
      [id]="popoverId"
      clrFocusTrap
      *clrPopoverContent="openState; at: smartPosition; outsideClickToClose: true; scrollToClose: true"
    >
      <div class="switch-header">
        <div class="clr-sr-only" tabindex="-1" #allSelected>{{ commonStrings.keys.allColumnsSelected }}</div>
        <ng-container *ngIf="!customToggleTitle">{{ commonStrings.keys.showColumns }}</ng-container>
        <ng-content select="clr-dg-column-toggle-title"></ng-content>
        <button
          class="btn btn-sm btn-link toggle-switch-close-button"
          clrPopoverCloseButton
          type="button"
          [attr.aria-label]="commonStrings.keys.close"
          [attr.title]="commonStrings.keys.close"
        >
          <cds-icon shape="window-close" aria-hidden="true" [attr.title]="commonStrings.keys.close"></cds-icon>
        </button>
      </div>
      <ul class="switch-content list-unstyled">
        <li *ngFor="let columnState of hideableColumnStates; trackBy: trackByFn">
          <clr-checkbox-wrapper>
            <input
              clrCheckbox
              type="checkbox"
              [disabled]="hasOnlyOneVisibleColumn && !columnState.hidden"
              [ngModel]="!columnState.hidden"
              (ngModelChange)="toggleColumnState(columnState, !$event)"
            />
            <label>
              <ng-template [ngTemplateOutlet]="columnState.titleTemplateRef"></ng-template>
            </label>
          </clr-checkbox-wrapper>
        </li>
      </ul>
      <div class="switch-footer">
        <ng-content select="clr-dg-column-toggle-button"></ng-content>
        <clr-dg-column-toggle-button *ngIf="!customToggleButton" (clrAllSelected)="allColumnsSelected()">
          {{ commonStrings.keys.selectAll }}
        </clr-dg-column-toggle-button>
      </div>
    </div>
  `,
                host: { '[class.column-switch-wrapper]': 'true', '[class.active]': 'openState' },
                providers: [UNIQUE_ID_PROVIDER, ClrPopoverEventsService, ClrPopoverPositionService, ClrPopoverToggleService]
            },] }
];
ClrDatagridColumnToggle.ctorParameters = () => [
    { type: ClrCommonStringsService },
    { type: ColumnsService },
    { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NgZone },
    { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] }
];
ClrDatagridColumnToggle.propDecorators = {
    customToggleTitle: [{ type: ContentChild, args: [ClrDatagridColumnToggleTitle,] }],
    customToggleButton: [{ type: ContentChild, args: [ClrDatagridColumnToggleButton,] }],
    allSelectedElement: [{ type: ViewChild, args: ['allSelected', { read: ElementRef },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUU1RyxPQUFPLEVBQUUsU0FBUyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sK0NBQStDLENBQUM7QUFFOUYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzlELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDOUQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sc0RBQXNELENBQUM7QUFDL0YsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sd0RBQXdELENBQUM7QUFDbkcsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sc0RBQXNELENBQUM7QUFDL0YsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFDbEYsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRTdELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3BFLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQzlFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBa0VoRiwyQ0FBMkM7QUFDM0MsTUFBTSxPQUFPLHVCQUF1QjtJQXlCbEMsWUFDUyxhQUFzQyxFQUNyQyxjQUE4QixF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QzdHOzs7WUF0RVEsdUJBQXVCO1lBQ3ZCLGNBQWM7eUNBbUdsQixNQUFNLFNBQUMsU0FBUzs0Q0FDaEIsTUFBTSxTQUFDLFdBQVc7WUEvRytCLE1BQU07eUNBaUh2RCxNQUFNLFNBQUMsU0FBUzs7O2dDQW5CbEIsWUFBWSxTQUFDLDRCQUE0QjtpQ0FDekMsWUFBWSxTQUFDLDZCQUE2QjtpQ0FDMUMsU0FBUyxTQUFDLGFBQWEsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjIgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5qZWN0LCBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWYsIE5nWm9uZSwgUExBVEZPUk1fSUQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBVTklRVUVfSUQsIFVOSVFVRV9JRF9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3V0aWxzL2lkLWdlbmVyYXRvci9pZC1nZW5lcmF0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyUG9zaXRpb24gfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL2ludGVyZmFjZXMvcG9wb3Zlci1wb3NpdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2xyQXhpcyB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvZW51bXMvYXhpcy5lbnVtJztcbmltcG9ydCB7IENsckFsaWdubWVudCB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvZW51bXMvYWxpZ25tZW50LmVudW0nO1xuaW1wb3J0IHsgQ2xyU2lkZSB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvZW51bXMvc2lkZS5lbnVtJztcbmltcG9ydCB7IENsclBvcG92ZXJFdmVudHNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9wcm92aWRlcnMvcG9wb3Zlci1ldmVudHMuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyUG9zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9wcm92aWRlcnMvcG9wb3Zlci1wb3NpdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9wcm92aWRlcnMvcG9wb3Zlci10b2dnbGUuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5pbXBvcnQgeyBDb2x1bW5zU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbHVtbnMuc2VydmljZSc7XG5pbXBvcnQgeyBDb2x1bW5TdGF0ZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb2x1bW4tc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IERhdGFncmlkQ29sdW1uQ2hhbmdlcyB9IGZyb20gJy4vZW51bXMvY29sdW1uLWNoYW5nZXMuZW51bSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLXRpdGxlJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLWJ1dHRvbic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4tdG9nZ2xlJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8YnV0dG9uXG4gICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1saW5rIGNvbHVtbi10b2dnbGUtLWFjdGlvblwiXG4gICAgICBjbHJQb3BvdmVyQW5jaG9yXG4gICAgICBjbHJQb3BvdmVyT3BlbkNsb3NlQnV0dG9uXG4gICAgICBbYXR0ci5hcmlhLWNvbnRyb2xzXT1cInBvcG92ZXJJZFwiXG4gICAgICBbYXR0ci5hcmlhLW93bnNdPVwicG9wb3ZlcklkXCJcbiAgICAgIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mua2V5cy5waWNrQ29sdW1uc1wiXG4gICAgPlxuICAgICAgPGNkcy1pY29uIHNoYXBlPVwidmlldy1jb2x1bW5zXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5rZXlzLnBpY2tDb2x1bW5zXCI+PC9jZHMtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8ZGl2XG4gICAgICBjbGFzcz1cImNvbHVtbi1zd2l0Y2hcIlxuICAgICAgcm9sZT1cImRpYWxvZ1wiXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNvbW1vblN0cmluZ3Mua2V5cy5zaG93Q29sdW1uc01lbnVEZXNjcmlwdGlvblwiXG4gICAgICBbaWRdPVwicG9wb3ZlcklkXCJcbiAgICAgIGNsckZvY3VzVHJhcFxuICAgICAgKmNsclBvcG92ZXJDb250ZW50PVwib3BlblN0YXRlOyBhdDogc21hcnRQb3NpdGlvbjsgb3V0c2lkZUNsaWNrVG9DbG9zZTogdHJ1ZTsgc2Nyb2xsVG9DbG9zZTogdHJ1ZVwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1oZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1zci1vbmx5XCIgdGFiaW5kZXg9XCItMVwiICNhbGxTZWxlY3RlZD57eyBjb21tb25TdHJpbmdzLmtleXMuYWxsQ29sdW1uc1NlbGVjdGVkIH19PC9kaXY+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhY3VzdG9tVG9nZ2xlVGl0bGVcIj57eyBjb21tb25TdHJpbmdzLmtleXMuc2hvd0NvbHVtbnMgfX08L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGUtdGl0bGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmsgdG9nZ2xlLXN3aXRjaC1jbG9zZS1idXR0b25cIlxuICAgICAgICAgIGNsclBvcG92ZXJDbG9zZUJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmNsb3NlXCJcbiAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmtleXMuY2xvc2VcIlxuICAgICAgICA+XG4gICAgICAgICAgPGNkcy1pY29uIHNoYXBlPVwid2luZG93LWNsb3NlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmNsb3NlXCI+PC9jZHMtaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDx1bCBjbGFzcz1cInN3aXRjaC1jb250ZW50IGxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjb2x1bW5TdGF0ZSBvZiBoaWRlYWJsZUNvbHVtblN0YXRlczsgdHJhY2tCeTogdHJhY2tCeUZuXCI+XG4gICAgICAgICAgPGNsci1jaGVja2JveC13cmFwcGVyPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIGNsckNoZWNrYm94XG4gICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJoYXNPbmx5T25lVmlzaWJsZUNvbHVtbiAmJiAhY29sdW1uU3RhdGUuaGlkZGVuXCJcbiAgICAgICAgICAgICAgW25nTW9kZWxdPVwiIWNvbHVtblN0YXRlLmhpZGRlblwiXG4gICAgICAgICAgICAgIChuZ01vZGVsQ2hhbmdlKT1cInRvZ2dsZUNvbHVtblN0YXRlKGNvbHVtblN0YXRlLCAhJGV2ZW50KVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sdW1uU3RhdGUudGl0bGVUZW1wbGF0ZVJlZlwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgIDwvY2xyLWNoZWNrYm94LXdyYXBwZXI+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L3VsPlxuICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1mb290ZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGUtYnV0dG9uXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8Y2xyLWRnLWNvbHVtbi10b2dnbGUtYnV0dG9uICpuZ0lmPVwiIWN1c3RvbVRvZ2dsZUJ1dHRvblwiIChjbHJBbGxTZWxlY3RlZCk9XCJhbGxDb2x1bW5zU2VsZWN0ZWQoKVwiPlxuICAgICAgICAgIHt7IGNvbW1vblN0cmluZ3Mua2V5cy5zZWxlY3RBbGwgfX1cbiAgICAgICAgPC9jbHItZGctY29sdW1uLXRvZ2dsZS1idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmNvbHVtbi1zd2l0Y2gtd3JhcHBlcl0nOiAndHJ1ZScsICdbY2xhc3MuYWN0aXZlXSc6ICdvcGVuU3RhdGUnIH0sXG4gIHByb3ZpZGVyczogW1VOSVFVRV9JRF9QUk9WSURFUiwgQ2xyUG9wb3ZlckV2ZW50c1NlcnZpY2UsIENsclBvcG92ZXJQb3NpdGlvblNlcnZpY2UsIENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlXSxcbn0pXG4vKiogQGRlcHJlY2F0ZWQgc2luY2UgMi4wLCByZW1vdmUgaW4gMy4wICovXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGUge1xuICBwcml2YXRlIF9hbGxDb2x1bW5zVmlzaWJsZTogYm9vbGVhbjtcblxuICAvLyBTbWFydCBQb3BvdmVyXG4gIHB1YmxpYyBzbWFydFBvc2l0aW9uOiBDbHJQb3BvdmVyUG9zaXRpb24gPSB7XG4gICAgYXhpczogQ2xyQXhpcy5WRVJUSUNBTCxcbiAgICBzaWRlOiBDbHJTaWRlLkJFRk9SRSxcbiAgICBhbmNob3I6IENsckFsaWdubWVudC5TVEFSVCxcbiAgICBjb250ZW50OiBDbHJBbGlnbm1lbnQuU1RBUlQsXG4gIH07XG4gIHB1YmxpYyBvcGVuU3RhdGU6IGJvb2xlYW47XG5cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlKSBjdXN0b21Ub2dnbGVUaXRsZTogQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZTtcbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbikgY3VzdG9tVG9nZ2xlQnV0dG9uOiBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbjtcbiAgQFZpZXdDaGlsZCgnYWxsU2VsZWN0ZWQnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgcHJpdmF0ZSBhbGxTZWxlY3RlZEVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gIHB1YmxpYyBnZXQgYWxsQ29sdW1uc1Zpc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbENvbHVtbnNWaXNpYmxlO1xuICB9XG5cbiAgcHVibGljIHNldCBhbGxDb2x1bW5zVmlzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2FsbENvbHVtbnNWaXNpYmxlID0gdmFsdWU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb2x1bW5zU2VydmljZTogQ29sdW1uc1NlcnZpY2UsXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyBjb2x1bW5Td2l0Y2hJZDogc3RyaW5nLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogYW55LFxuICAgIHByaXZhdGUgem9uZTogTmdab25lLFxuICAgIEBJbmplY3QoVU5JUVVFX0lEKSBwdWJsaWMgcG9wb3ZlcklkOiBzdHJpbmdcbiAgKSB7fVxuXG4gIGdldCBoaWRlYWJsZUNvbHVtblN0YXRlcygpOiBDb2x1bW5TdGF0ZVtdIHtcbiAgICBjb25zdCBoaWRlYWJsZXMgPSB0aGlzLmNvbHVtbnNTZXJ2aWNlLmNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4udmFsdWUuaGlkZWFibGUpO1xuICAgIHJldHVybiBoaWRlYWJsZXMubWFwKGNvbHVtbiA9PiBjb2x1bW4udmFsdWUpO1xuICB9XG5cbiAgZ2V0IGhhc09ubHlPbmVWaXNpYmxlQ29sdW1uKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5iTm9uSGlkZWFibGVDb2x1bW5zID0gdGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zLmxlbmd0aCAtIHRoaXMuaGlkZWFibGVDb2x1bW5TdGF0ZXMubGVuZ3RoO1xuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgcmV0dXJuIHRydWUgd2hlbiB0aGVyZSBpcyBubyBub24taGlkZWFibGUgY29sdW1ucy5cbiAgICByZXR1cm4gKFxuICAgICAgbmJOb25IaWRlYWJsZUNvbHVtbnMgPT09IDAgJiYgdGhpcy5oaWRlYWJsZUNvbHVtblN0YXRlcy5maWx0ZXIoY29sdW1uU3RhdGUgPT4gIWNvbHVtblN0YXRlLmhpZGRlbikubGVuZ3RoID09PSAxXG4gICAgKTtcbiAgfVxuXG4gIHRvZ2dsZUNvbHVtblN0YXRlKGNvbHVtblN0YXRlOiBDb2x1bW5TdGF0ZSwgZXZlbnQ6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb2x1bW5Ub1RvZ2dsZSA9IHRoaXMuY29sdW1uc1NlcnZpY2UuY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi52YWx1ZSA9PT0gY29sdW1uU3RhdGUpWzBdO1xuICAgIHRoaXMuY29sdW1uc1NlcnZpY2UuZW1pdFN0YXRlQ2hhbmdlKGNvbHVtblRvVG9nZ2xlLCB7XG4gICAgICBoaWRkZW46IGV2ZW50LFxuICAgICAgY2hhbmdlczogW0RhdGFncmlkQ29sdW1uQ2hhbmdlcy5ISURERU5dLFxuICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlU3dpdGNoUGFuZWwoKSB7XG4gICAgdGhpcy5vcGVuU3RhdGUgPSAhdGhpcy5vcGVuU3RhdGU7XG4gIH1cblxuICBhbGxDb2x1bW5zU2VsZWN0ZWQoKSB7XG4gICAgdGhpcy5hbGxTZWxlY3RlZEVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0cmFja2luZyB0aGUgY2hlY2tib3hlcyBnZXQgcmVyZW5kZXJlZCBvbiBtb2RlbCB1cGRhdGUsIHdoaWNoIGxlYWRzXG4gIC8vIHRvIGxvc3Mgb2YgZm9jdXMgYWZ0ZXIgY2hlY2tib3ggdG9nZ2xlLlxuICB0cmFja0J5Rm4oaW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxufVxuIl19