import { ChangeDetectionStrategy, ChangeDetectorRef, Component, HostBinding, Input, ViewChildren, } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { NODE_HEIGHT } from './constants';
import { OrderProcessNodeComponent } from './order-process-node.component';
export class OrderProcessGraphComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.setActiveState$ = new BehaviorSubject(undefined);
        this.nodes = [];
        this.edges = [];
    }
    get outerHeight() {
        return this.nodes.length * NODE_HEIGHT;
    }
    ngOnInit() {
        this.setActiveState$.next(this.initialState);
        this.activeState$ = this.setActiveState$.pipe(debounceTime(150));
    }
    ngOnChanges(changes) {
        this.populateNodes();
    }
    ngAfterViewInit() {
        setTimeout(() => this.populateEdges());
    }
    onMouseOver(stateName) {
        this.setActiveState$.next(stateName);
    }
    onMouseOut() {
        this.setActiveState$.next(this.initialState);
    }
    getNodeFor(state) {
        if (this.nodeComponents) {
            return this.nodeComponents.find((n) => n.node.name === state);
        }
    }
    populateNodes() {
        var _a, _b;
        const stateNodeMap = new Map();
        for (const state of this.states) {
            stateNodeMap.set(state.name, {
                name: state.name,
                to: [],
            });
        }
        for (const [name, stateNode] of stateNodeMap.entries()) {
            const targets = (_b = (_a = this.states.find((s) => s.name === name)) === null || _a === void 0 ? void 0 : _a.to) !== null && _b !== void 0 ? _b : [];
            for (const target of targets) {
                const targetNode = stateNodeMap.get(target);
                if (targetNode) {
                    stateNode.to.push(targetNode);
                }
            }
        }
        this.nodes = [...stateNodeMap.values()].filter((n) => n.name !== 'Cancelled');
    }
    populateEdges() {
        for (const node of this.nodes) {
            const nodeCmp = this.getNodeFor(node.name);
            let index = 0;
            for (const to of node.to) {
                const toCmp = this.getNodeFor(to.name);
                if (nodeCmp && toCmp && nodeCmp !== toCmp) {
                    this.edges.push({
                        to: toCmp,
                        from: nodeCmp,
                        index,
                    });
                    index++;
                }
            }
        }
        this.edges = [...this.edges];
        this.changeDetector.markForCheck();
    }
}
OrderProcessGraphComponent.decorators = [
    { type: Component, args: [{
                selector: 'vdr-order-process-graph',
                template: "<ng-container *ngFor=\"let state of nodes; let i = index\">\r\n    <vdr-order-process-node\r\n        [node]=\"state\"\r\n        [index]=\"i\"\r\n        [active]=\"(activeState$ | async) === state.name\"\r\n        (mouseenter)=\"onMouseOver(state.name)\"\r\n        (mouseleave)=\"onMouseOut()\"\r\n    ></vdr-order-process-node>\r\n</ng-container>\r\n<ng-container *ngFor=\"let edge of edges\">\r\n    <vdr-order-process-edge [from]=\"edge.from\" [to]=\"edge.to\" [index]=\"edge.index\"></vdr-order-process-edge>\r\n</ng-container>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block;border:1px hotpink;margin:20px;padding:12px;position:relative}.state-row{display:flex}\n"]
            },] }
];
OrderProcessGraphComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
OrderProcessGraphComponent.propDecorators = {
    states: [{ type: Input }],
    initialState: [{ type: Input }],
    nodeComponents: [{ type: ViewChildren, args: [OrderProcessNodeComponent,] }],
    outerHeight: [{ type: HostBinding, args: ['style.height.px',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL29yZGVyL3NyYy9jb21wb25lbnRzL29yZGVyLXByb2Nlc3MtZ3JhcGgvb3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVILHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBS0wsWUFBWSxHQUNmLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxlQUFlLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDbkQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTlDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDMUMsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFTM0UsTUFBTSxPQUFPLDBCQUEwQjtJQVVuQyxZQUFvQixjQUFpQztRQUFqQyxtQkFBYyxHQUFkLGNBQWMsQ0FBbUI7UUFQckQsb0JBQWUsR0FBRyxJQUFJLGVBQWUsQ0FBcUIsU0FBUyxDQUFDLENBQUM7UUFFckUsVUFBSyxHQUFnQixFQUFFLENBQUM7UUFDeEIsVUFBSyxHQUE2RixFQUFFLENBQUM7SUFJN0MsQ0FBQztJQUV6RCxJQUNJLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLFdBQVcsQ0FBQztJQUMzQyxDQUFDO0lBRUQsUUFBUTtRQUNKLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFF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Q0FBQztJQUN2QyxDQUFDOzs7WUF6RkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSx5QkFBeUI7Z0JBQ25DLHVpQkFBbUQ7Z0JBRW5ELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOzthQUNsRDs7O1lBdkJHLGlCQUFpQjs7O3FCQXlCaEIsS0FBSzsyQkFDTCxLQUFLOzZCQU1MLFlBQVksU0FBQyx5QkFBeUI7MEJBSXRDLFdBQVcsU0FBQyxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgQWZ0ZXJWaWV3SW5pdCxcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBIb3N0QmluZGluZyxcclxuICAgIElucHV0LFxyXG4gICAgT25DaGFuZ2VzLFxyXG4gICAgT25Jbml0LFxyXG4gICAgUXVlcnlMaXN0LFxyXG4gICAgU2ltcGxlQ2hhbmdlcyxcclxuICAgIFZpZXdDaGlsZHJlbixcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT3JkZXJQcm9jZXNzU3RhdGUgfSBmcm9tICdAdmVuZHVyZS9hZG1pbi11aS9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IE5PREVfSEVJR0hUIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50IH0gZnJvbSAnLi9vcmRlci1wcm9jZXNzLW5vZGUuY29tcG9uZW50JztcclxuaW1wb3J0IHsgU3RhdGVOb2RlIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndmRyLW9yZGVyLXByb2Nlc3MtZ3JhcGgnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL29yZGVyLXByb2Nlc3MtZ3JhcGguY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vb3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQuc2NzcyddLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBPcmRlclByb2Nlc3NHcmFwaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0IHtcclxuICAgIEBJbnB1dCgpIHN0YXRlczogT3JkZXJQcm9jZXNzU3RhdGVbXTtcclxuICAgIEBJbnB1dCgpIGluaXRpYWxTdGF0ZT86IHN0cmluZztcclxuICAgIHNldEFjdGl2ZVN0YXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG4gICAgYWN0aXZlU3RhdGUkOiBPYnNlcnZhYmxlPHN0cmluZyB8IHVuZGVmaW5lZD47XHJcbiAgICBub2RlczogU3RhdGVOb2RlW10gPSBbXTtcclxuICAgIGVkZ2VzOiBBcnJheTx7IGZyb206IE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQ7IHRvOiBPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50OyBpbmRleDogbnVtYmVyIH0+ID0gW107XHJcblxyXG4gICAgQFZpZXdDaGlsZHJlbihPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50KSBub2RlQ29tcG9uZW50czogUXVlcnlMaXN0PE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQ+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmKSB7fVxyXG5cclxuICAgIEBIb3N0QmluZGluZygnc3R5bGUuaGVpZ2h0LnB4JylcclxuICAgIGdldCBvdXRlckhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCAqIE5PREVfSEVJR0hUO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU3RhdGUkLm5leHQodGhpcy5pbml0aWFsU3RhdGUpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGUkID0gdGhpcy5zZXRBY3RpdmVTdGF0ZSQucGlwZShkZWJvdW5jZVRpbWUoMTUwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMucG9wdWxhdGVOb2RlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucG9wdWxhdGVFZGdlcygpKTtcclxuICAgIH1cclxuXHJcbiAgICBvbk1vdXNlT3ZlcihzdGF0ZU5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU3RhdGUkLm5leHQoc3RhdGVOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBvbk1vdXNlT3V0KCkge1xyXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU3RhdGUkLm5leHQodGhpcy5pbml0aWFsU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5vZGVGb3Ioc3RhdGU6IHN0cmluZyk6IE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGVDb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVDb21wb25lbnRzLmZpbmQoKG4pID0+IG4ubm9kZS5uYW1lID09PSBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcG9wdWxhdGVOb2RlcygpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZU5vZGVNYXAgPSBuZXcgTWFwPHN0cmluZywgU3RhdGVOb2RlPigpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcclxuICAgICAgICAgICAgc3RhdGVOb2RlTWFwLnNldChzdGF0ZS5uYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgdG86IFtdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHN0YXRlTm9kZV0gb2Ygc3RhdGVOb2RlTWFwLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRzID0gdGhpcy5zdGF0ZXMuZmluZCgocykgPT4gcy5uYW1lID09PSBuYW1lKT8udG8gPz8gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdGF0ZU5vZGVNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTm9kZS50by5wdXNoKHRhcmdldE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbLi4uc3RhdGVOb2RlTWFwLnZhbHVlcygpXS5maWx0ZXIoKG4pID0+IG4ubmFtZSAhPT0gJ0NhbmNlbGxlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcG9wdWxhdGVFZGdlcygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlQ21wID0gdGhpcy5nZXROb2RlRm9yKG5vZGUubmFtZSk7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG8gb2Ygbm9kZS50bykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9DbXAgPSB0aGlzLmdldE5vZGVGb3IodG8ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZUNtcCAmJiB0b0NtcCAmJiBub2RlQ21wICE9PSB0b0NtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0b0NtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbm9kZUNtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVkZ2VzID0gWy4uLnRoaXMuZWRnZXNdO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbn1cclxuIl19