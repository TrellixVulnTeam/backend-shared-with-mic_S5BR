import { __awaiter } from "tslib";
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { FormControl } from '@angular/forms';
import { marker as _ } from '@biesbjerg/ngx-translate-extract-marker';
import { NotificationService } from '@vendure/admin-ui/core';
import { DataService } from '@vendure/admin-ui/core';
import { combineLatest, from } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
export class AssignProductsToChannelDialogComponent {
    constructor(dataService, notificationService) {
        this.dataService = dataService;
        this.notificationService = notificationService;
        this.priceFactorControl = new FormControl(1);
        this.selectedChannelIdControl = new FormControl();
    }
    get isProductVariantMode() {
        return this.productVariantIds != null;
    }
    ngOnInit() {
        const activeChannelId$ = this.dataService.client
            .userStatus()
            .mapSingle(({ userStatus }) => userStatus.activeChannelId);
        const allChannels$ = this.dataService.settings.getChannels().mapSingle(data => data.channels);
        combineLatest(activeChannelId$, allChannels$).subscribe(([activeChannelId, channels]) => {
            // tslint:disable-next-line:no-non-null-assertion
            this.currentChannel = channels.find(c => c.id === activeChannelId);
            this.availableChannels = channels;
        });
        this.selectedChannelIdControl.valueChanges.subscribe(ids => {
            this.selectChannel(ids);
        });
        this.variantsPreview$ = combineLatest(from(this.getTopVariants(10)), this.priceFactorControl.valueChanges.pipe(startWith(1))).pipe(map(([variants, factor]) => {
            return variants.map(v => ({
                id: v.id,
                name: v.name,
                price: v.price,
                pricePreview: v.price * +factor,
            }));
        }));
    }
    selectChannel(channelIds) {
        this.selectedChannel = this.availableChannels.find(c => c.id === channelIds[0]);
    }
    assign() {
        const selectedChannel = this.selectedChannel;
        if (selectedChannel) {
            if (!this.isProductVariantMode) {
                this.dataService.product
                    .assignProductsToChannel({
                    channelId: selectedChannel.id,
                    productIds: this.productIds,
                    priceFactor: +this.priceFactorControl.value,
                })
                    .subscribe(() => {
                    this.notificationService.success(_('catalog.assign-product-to-channel-success'), {
                        channel: selectedChannel.code,
                    });
                    this.resolveWith(true);
                });
            }
            else if (this.productVariantIds) {
                this.dataService.product
                    .assignVariantsToChannel({
                    channelId: selectedChannel.id,
                    productVariantIds: this.productVariantIds,
                    priceFactor: +this.priceFactorControl.value,
                })
                    .subscribe(() => {
                    this.notificationService.success(_('catalog.assign-variant-to-channel-success'), {
                        channel: selectedChannel.code,
                    });
                    this.resolveWith(true);
                });
            }
        }
    }
    cancel() {
        this.resolveWith();
    }
    getTopVariants(take) {
        return __awaiter(this, void 0, void 0, function* () {
            const variants = [];
            for (let i = 0; i < this.productIds.length && variants.length < take; i++) {
                const productVariants = yield this.dataService.product
                    .getProduct(this.productIds[i], { take: this.isProductVariantMode ? undefined : take })
                    .mapSingle(({ product }) => {
                    const _variants = product ? product.variantList.items : [];
                    return _variants.filter(v => { var _a; return this.isProductVariantMode ? (_a = this.productVariantIds) === null || _a === void 0 ? void 0 : _a.includes(v.id) : true; });
                })
                    .toPromise();
                variants.push(...(productVariants || []));
            }
            return variants.slice(0, take);
        });
    }
}
AssignProductsToChannelDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'vdr-assign-products-to-channel-dialog',
                template: "<ng-template vdrDialogTitle>\r\n    <ng-container *ngIf=\"isProductVariantMode; else productModeTitle\">{{\r\n        'catalog.assign-variants-to-channel' | translate\r\n    }}</ng-container>\r\n    <ng-template #productModeTitle>{{ 'catalog.assign-products-to-channel' | translate }}</ng-template>\r\n</ng-template>\r\n\r\n<div class=\"flex\">\r\n    <clr-input-container>\r\n        <label>{{ 'common.channel' | translate }}</label>\r\n        <vdr-channel-assignment-control\r\n            clrInput\r\n            [multiple]=\"false\"\r\n            [includeDefaultChannel]=\"false\"\r\n            [disableChannelIds]=\"currentChannelIds\"\r\n            [formControl]=\"selectedChannelIdControl\"\r\n        ></vdr-channel-assignment-control>\r\n    </clr-input-container>\r\n    <div class=\"flex-spacer\"></div>\r\n    <clr-input-container>\r\n        <label>{{ 'catalog.price-conversion-factor' | translate }}</label>\r\n        <input clrInput type=\"number\" min=\"0\" max=\"99999\" [formControl]=\"priceFactorControl\" />\r\n    </clr-input-container>\r\n</div>\r\n\r\n<div class=\"channel-price-preview\">\r\n    <label class=\"clr-control-label\">{{ 'catalog.channel-price-preview' | translate }}</label>\r\n    <table class=\"table\">\r\n        <thead>\r\n            <tr>\r\n                <th>{{ 'common.name' | translate }}</th>\r\n                <th>\r\n                    {{\r\n                        'catalog.price-in-channel'\r\n                            | translate: { channel: currentChannel?.code | channelCodeToLabel | translate }\r\n                    }}\r\n                </th>\r\n                <th>\r\n                    <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noSelection\">\r\n                        {{ 'catalog.price-in-channel' | translate: { channel: selectedChannel?.code } }}\r\n                    </ng-template>\r\n                    <ng-template #noSelection>\r\n                        {{ 'catalog.no-channel-selected' | translate }}\r\n                    </ng-template>\r\n                </th>\r\n            </tr>\r\n        </thead>\r\n        <tbody>\r\n            <tr *ngFor=\"let row of variantsPreview$ | async\">\r\n                <td>{{ row.name }}</td>\r\n                <td>{{ row.price | localeCurrency: currentChannel?.currencyCode }}</td>\r\n                <td>\r\n                    <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noChannelSelected\">\r\n                        {{ row.pricePreview | localeCurrency: selectedChannel?.currencyCode }}\r\n                    </ng-template>\r\n                    <ng-template #noChannelSelected> - </ng-template>\r\n                </td>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</div>\r\n\r\n<ng-template vdrDialogButtons>\r\n    <button type=\"button\" class=\"btn\" (click)=\"cancel()\">{{ 'common.cancel' | translate }}</button>\r\n    <button type=\"submit\" (click)=\"assign()\" [disabled]=\"!selectedChannel\" class=\"btn btn-primary\">\r\n        <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noSelection\">\r\n            {{ 'catalog.assign-to-named-channel' | translate: { channelCode: selectedChannel?.code } }}\r\n        </ng-template>\r\n        <ng-template #noSelection>\r\n            {{ 'catalog.no-channel-selected' | translate }}\r\n        </ng-template>\r\n    </button>\r\n</ng-template>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: ["vdr-channel-assignment-control{min-width:200px}.channel-price-preview{margin-top:24px}.channel-price-preview table.table{margin-top:6px}\n"]
            },] }
];
AssignProductsToChannelDialogComponent.ctorParameters = () => [
    { type: DataService },
    { type: NotificationService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzaWduLXByb2R1Y3RzLXRvLWNoYW5uZWwtZGlhbG9nLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy9hc3NpZ24tcHJvZHVjdHMtdG8tY2hhbm5lbC1kaWFsb2cvYXNzaWduLXByb2R1Y3RzLXRvLWNoYW5uZWwtZGlhbG9nLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUMzRSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUV0RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM3RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFckQsT0FBTyxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDdkQsT0FBTyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQWEsTUFBTSxnQkFBZ0IsQ0FBQztBQVEzRCxNQUFNLE9BQU8sc0NBQXNDO0lBa0IvQyxZQUFvQixXQUF3QixFQUFVLG1CQUF3QztRQUExRSxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUFVLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFaOUYsdUJBQWtCLEdBQUcsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEMsNkJBQXdCLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztJQVdvRCxDQUFDO0lBSmxHLElBQUksb0JBQW9CO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQztJQUMxQyxDQUFDO0lBSUQsUUFBUTtRQUNKLE1BQU0sZ0JBQWdCLEdB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QU8sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7b0JBQzNELE9BQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxXQUN4QixPQUFBLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsTUFBQSxJQUFJLENBQUMsaUJBQWlCLDBDQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQSxFQUFBLENBQzVFLENBQUM7Z0JBQ04sQ0FBQyxDQUFDO3FCQUNELFNBQVMsRUFBRSxDQUFDO2dCQUNqQixRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQzthQUM3QztZQUNELE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbkMsQ0FBQztLQUFBOzs7WUFsSEosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSx1Q0FBdUM7Z0JBQ2pELGkwR0FBaUU7Z0JBRWpFLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOzthQUNsRDs7O1lBVlEsV0FBVztZQURYLG1CQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgbWFya2VyIGFzIF8gfSBmcm9tICdAYmllc2JqZXJnL25neC10cmFuc2xhdGUtZXh0cmFjdC1tYXJrZXInO1xyXG5pbXBvcnQgeyBHZXRDaGFubmVscywgUHJvZHVjdFZhcmlhbnRGcmFnbWVudCB9IGZyb20gJ0B2ZW5kdXJlL2FkbWluLXVpL2NvcmUnO1xyXG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlIH0gZnJvbSAnQHZlbmR1cmUvYWRtaW4tdWkvY29yZSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnQHZlbmR1cmUvYWRtaW4tdWkvY29yZSc7XHJcbmltcG9ydCB7IERpYWxvZyB9IGZyb20gJ0B2ZW5kdXJlL2FkbWluLXVpL2NvcmUnO1xyXG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBmcm9tLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndmRyLWFzc2lnbi1wcm9kdWN0cy10by1jaGFubmVsLWRpYWxvZycsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vYXNzaWduLXByb2R1Y3RzLXRvLWNoYW5uZWwtZGlhbG9nLmNvbXBvbmVudC5odG1sJyxcclxuICAgIHN0eWxlVXJsczogWycuL2Fzc2lnbi1wcm9kdWN0cy10by1jaGFubmVsLWRpYWxvZy5jb21wb25lbnQuc2NzcyddLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBc3NpZ25Qcm9kdWN0c1RvQ2hhbm5lbERpYWxvZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgRGlhbG9nPGFueT4ge1xyXG4gICAgc2VsZWN0ZWRDaGFubmVsOiBHZXRDaGFubmVscy5DaGFubmVscyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBjdXJyZW50Q2hhbm5lbDogR2V0Q2hhbm5lbHMuQ2hhbm5lbHM7XHJcbiAgICBhdmFpbGFibGVDaGFubmVsczogR2V0Q2hhbm5lbHMuQ2hhbm5lbHNbXTtcclxuICAgIHJlc29sdmVXaXRoOiAocmVzdWx0PzogYW55KSA9PiB2b2lkO1xyXG4gICAgdmFyaWFudHNQcmV2aWV3JDogT2JzZXJ2YWJsZTxBcnJheTx7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcHJpY2VQcmV2aWV3OiBudW1iZXIgfT4+O1xyXG4gICAgcHJpY2VGYWN0b3JDb250cm9sID0gbmV3IEZvcm1Db250cm9sKDEpO1xyXG4gICAgc2VsZWN0ZWRDaGFubmVsSWRDb250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XHJcblxyXG4gICAgLy8gYXNzaWduZWQgYnkgTW9kYWxTZXJ2aWNlLmZyb21Db21wb25lbnQoKSBjYWxsXHJcbiAgICBwcm9kdWN0SWRzOiBzdHJpbmdbXTtcclxuICAgIHByb2R1Y3RWYXJpYW50SWRzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcclxuICAgIGN1cnJlbnRDaGFubmVsSWRzOiBzdHJpbmdbXTtcclxuXHJcbiAgICBnZXQgaXNQcm9kdWN0VmFyaWFudE1vZGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvZHVjdFZhcmlhbnRJZHMgIT0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGFTZXJ2aWNlOiBEYXRhU2VydmljZSwgcHJpdmF0ZSBub3RpZmljYXRpb25TZXJ2aWNlOiBOb3RpZmljYXRpb25TZXJ2aWNlKSB7fVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUNoYW5uZWxJZCQgPSB0aGlzLmRhdGFTZXJ2aWNlLmNsaWVudFxyXG4gICAgICAgICAgICAudXNlclN0YXR1cygpXHJcbiAgICAgICAgICAgIC5tYXBTaW5nbGUoKHsgdXNlclN0YXR1cyB9KSA9PiB1c2VyU3RhdHVzLmFjdGl2ZUNoYW5uZWxJZCk7XHJcbiAgICAgICAgY29uc3QgYWxsQ2hhbm5lbHMkID0gdGhpcy5kYXRhU2VydmljZS5zZXR0aW5ncy5nZXRDaGFubmVscygpLm1hcFNpbmdsZShkYXRhID0+IGRhdGEuY2hhbm5lbHMpO1xyXG5cclxuICAgICAgICBjb21iaW5lTGF0ZXN0KGFjdGl2ZUNoYW5uZWxJZCQsIGFsbENoYW5uZWxzJCkuc3Vic2NyaWJlKChbYWN0aXZlQ2hhbm5lbElkLCBjaGFubmVsc10pID0+IHtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hhbm5lbHMuZmluZChjID0+IGMuaWQgPT09IGFjdGl2ZUNoYW5uZWxJZCkhO1xyXG4gICAgICAgICAgICB0aGlzLmF2YWlsYWJsZUNoYW5uZWxzID0gY2hhbm5lbHM7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFubmVsSWRDb250cm9sLnZhbHVlQ2hhbmdlcy5zdWJzY3JpYmUoaWRzID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RDaGFubmVsKGlkcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMudmFyaWFudHNQcmV2aWV3JCA9IGNvbWJpbmVMYXRlc3QoXHJcbiAgICAgICAgICAgIGZyb20odGhpcy5nZXRUb3BWYXJpYW50cygxMCkpLFxyXG4gICAgICAgICAgICB0aGlzLnByaWNlRmFjdG9yQ29udHJvbC52YWx1ZUNoYW5nZXMucGlwZShzdGFydFdpdGgoMSkpLFxyXG4gICAgICAgICkucGlwZShcclxuICAgICAgICAgICAgbWFwKChbdmFyaWFudHMsIGZhY3Rvcl0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYW50cy5tYXAodiA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB2LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHYubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmljZTogdi5wcmljZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmljZVByZXZpZXc6IHYucHJpY2UgKiArZmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdENoYW5uZWwoY2hhbm5lbElkczogc3RyaW5nW10pIHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbm5lbCA9IHRoaXMuYXZhaWxhYmxlQ2hhbm5lbHMuZmluZChjID0+IGMuaWQgPT09IGNoYW5uZWxJZHNbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFzc2lnbigpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZENoYW5uZWwgPSB0aGlzLnNlbGVjdGVkQ2hhbm5lbDtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRDaGFubmVsKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Byb2R1Y3RWYXJpYW50TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhU2VydmljZS5wcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnblByb2R1Y3RzVG9DaGFubmVsKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkOiBzZWxlY3RlZENoYW5uZWwuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZHM6IHRoaXMucHJvZHVjdElkcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2VGYWN0b3I6ICt0aGlzLnByaWNlRmFjdG9yQ29udHJvbC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblNlcnZpY2Uuc3VjY2VzcyhfKCdjYXRhbG9nLmFzc2lnbi1wcm9kdWN0LXRvLWNoYW5uZWwtc3VjY2VzcycpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiBzZWxlY3RlZENoYW5uZWwuY29kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVdpdGgodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9kdWN0VmFyaWFudElkcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhU2VydmljZS5wcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnblZhcmlhbnRzVG9DaGFubmVsKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkOiBzZWxlY3RlZENoYW5uZWwuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RWYXJpYW50SWRzOiB0aGlzLnByb2R1Y3RWYXJpYW50SWRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZUZhY3RvcjogK3RoaXMucHJpY2VGYWN0b3JDb250cm9sLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uU2VydmljZS5zdWNjZXNzKF8oJ2NhdGFsb2cuYXNzaWduLXZhcmlhbnQtdG8tY2hhbm5lbC1zdWNjZXNzJyksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IHNlbGVjdGVkQ2hhbm5lbC5jb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlV2l0aCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlV2l0aCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0VG9wVmFyaWFudHModGFrZTogbnVtYmVyKTogUHJvbWlzZTxQcm9kdWN0VmFyaWFudEZyYWdtZW50W10+IHtcclxuICAgICAgICBjb25zdCB2YXJpYW50czogUHJvZHVjdFZhcmlhbnRGcmFnbWVudFtdID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcm9kdWN0SWRzLmxlbmd0aCAmJiB2YXJpYW50cy5sZW5ndGggPCB0YWtlOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFZhcmlhbnRzID0gYXdhaXQgdGhpcy5kYXRhU2VydmljZS5wcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAuZ2V0UHJvZHVjdCh0aGlzLnByb2R1Y3RJZHNbaV0sIHsgdGFrZTogdGhpcy5pc1Byb2R1Y3RWYXJpYW50TW9kZSA/IHVuZGVmaW5lZCA6IHRha2UgfSlcclxuICAgICAgICAgICAgICAgIC5tYXBTaW5nbGUoKHsgcHJvZHVjdCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX3ZhcmlhbnRzID0gcHJvZHVjdCA/IHByb2R1Y3QudmFyaWFudExpc3QuaXRlbXMgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhcmlhbnRzLmZpbHRlcih2ID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9kdWN0VmFyaWFudE1vZGUgPyB0aGlzLnByb2R1Y3RWYXJpYW50SWRzPy5pbmNsdWRlcyh2LmlkKSA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudG9Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHZhcmlhbnRzLnB1c2goLi4uKHByb2R1Y3RWYXJpYW50cyB8fCBbXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFyaWFudHMuc2xpY2UoMCwgdGFrZSk7XHJcbiAgICB9XHJcbn1cclxuIl19