import { Injectable } from '@angular/core';
import { DataService, DeletionResult, findTranslation, } from '@vendure/admin-ui/core';
import { normalizeString } from '@vendure/common/lib/normalize-string';
import { notNullOrUndefined } from '@vendure/common/lib/shared-utils';
import { forkJoin, of, throwError } from 'rxjs';
import { map, mergeMap, shareReplay, switchMap } from 'rxjs/operators';
import { replaceLast } from './replace-last';
import * as i0 from "@angular/core";
import * as i1 from "@vendure/admin-ui/core";
/**
 * Handles the logic for making the API calls to perform CRUD operations on a Product and its related
 * entities. This logic was extracted out of the component because it became too large and hard to follow.
 */
export class ProductDetailService {
    constructor(dataService) {
        this.dataService = dataService;
    }
    getFacets() {
        return this.dataService.facet.getAllFacets().mapSingle(data => data.facets.items);
    }
    getTaxCategories() {
        return this.dataService.settings
            .getTaxCategories()
            .mapSingle(data => data.taxCategories)
            .pipe(shareReplay(1));
    }
    createProductWithVariants(input, createVariantsConfig, languageCode) {
        const createProduct$ = this.dataService.product.createProduct(input);
        const nonEmptyOptionGroups = createVariantsConfig.groups.filter(g => 0 < g.values.length);
        const createOptionGroups$ = this.createProductOptionGroups(nonEmptyOptionGroups, languageCode);
        return forkJoin(createProduct$, createOptionGroups$).pipe(mergeMap(([{ createProduct }, optionGroups]) => {
            const addOptionsToProduct$ = optionGroups.length
                ? forkJoin(optionGroups.map(optionGroup => {
                    return this.dataService.product.addOptionGroupToProduct({
                        productId: createProduct.id,
                        optionGroupId: optionGroup.id,
                    });
                }))
                : of([]);
            return addOptionsToProduct$.pipe(map(() => {
                return { createProduct, optionGroups };
            }));
        }), mergeMap(({ createProduct, optionGroups }) => {
            const variants = createVariantsConfig.variants.map(v => {
                const optionIds = optionGroups.length
                    ? v.optionValues.map((optionName, index) => {
                        const option = optionGroups[index].options.find(o => o.name === optionName);
                        if (!option) {
                            throw new Error(`Could not find a matching ProductOption "${optionName}" when creating variant`);
                        }
                        return option.id;
                    })
                    : [];
                return Object.assign(Object.assign({}, v), { optionIds });
            });
            const options = optionGroups.map(og => og.options).reduce((flat, o) => [...flat, ...o], []);
            return this.createProductVariants(createProduct, variants, options, languageCode);
        }));
    }
    createProductOptionGroups(groups, languageCode) {
        return groups.length
            ? forkJoin(groups.map(c => {
                return this.dataService.product
                    .createProductOptionGroups({
                    code: normalizeString(c.name, '-'),
                    translations: [{ languageCode, name: c.name }],
                    options: c.values.map(v => ({
                        code: normalizeString(v, '-'),
                        translations: [{ languageCode, name: v }],
                    })),
                })
                    .pipe(map(data => data.createProductOptionGroup));
            }))
            : of([]);
    }
    createProductVariants(product, variantData, options, languageCode) {
        const variants = variantData.map(v => {
            const name = options.length
                ? `${product.name} ${v.optionIds
                    .map(id => options.find(o => o.id === id))
                    .filter(notNullOrUndefined)
                    .map(o => o.name)
                    .join(' ')}`
                : product.name;
            return {
                productId: product.id,
                price: v.price,
                sku: v.sku,
                stockOnHand: v.stock,
                translations: [
                    {
                        languageCode,
                        name,
                    },
                ],
                optionIds: v.optionIds,
            };
        });
        return this.dataService.product.createProductVariants(variants).pipe(map(({ createProductVariants }) => ({
            createProductVariants,
            productId: product.id,
        })));
    }
    updateProduct(updateOptions) {
        const { product, languageCode, autoUpdate, productInput, variantsInput } = updateOptions;
        const updateOperations = [];
        const updateVariantsInput = variantsInput || [];
        const variants$ = autoUpdate
            ? this.dataService.product
                .getProductVariants({}, product.id)
                .mapSingle(({ productVariants }) => productVariants.items)
            : of([]);
        return variants$.pipe(mergeMap(variants => {
            var _a, _b, _c, _d;
            if (productInput) {
                updateOperations.push(this.dataService.product.updateProduct(productInput));
                const productOldName = (_b = (_a = findTranslation(product, languageCode)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';
                const productNewName = (_c = findTranslation(productInput, languageCode)) === null || _c === void 0 ? void 0 : _c.name;
                if (productNewName && productOldName !== productNewName && autoUpdate) {
                    for (const variant of variants) {
                        const currentVariantName = ((_d = findTranslation(variant, languageCode)) === null || _d === void 0 ? void 0 : _d.name) || '';
                        let variantInput;
                        const existingVariantInput = updateVariantsInput.find(i => i.id === variant.id);
                        if (existingVariantInput) {
                            variantInput = existingVariantInput;
                        }
                        else {
                            variantInput = {
                                id: variant.id,
                                translations: [{ languageCode, name: currentVariantName }],
                            };
                            updateVariantsInput.push(variantInput);
                        }
                        const variantTranslation = findTranslation(variantInput, languageCode);
                        if (variantTranslation) {
                            if (variantTranslation.name) {
                                variantTranslation.name = replaceLast(variantTranslation.name, productOldName, productNewName);
                            }
                            else {
                                // The variant translation was falsy, which occurs
                                // when defining the product name for a new translation
                                // language that had not yet been defined.
                                variantTranslation.name = [
                                    productNewName,
                                    ...variant.options.map(o => o.name),
                                ].join(' ');
                            }
                        }
                    }
                }
            }
            if (updateVariantsInput.length) {
                updateOperations.push(this.dataService.product.updateProductVariants(updateVariantsInput));
            }
            return forkJoin(updateOperations);
        }));
    }
    updateProductOption(input, product, languageCode) {
        const variants$ = input.autoUpdate
            ? this.dataService.product
                .getProductVariants({}, product.id)
                .mapSingle(({ productVariants }) => productVariants.items)
            : of([]);
        return variants$.pipe(mergeMap(variants => {
            var _a, _b, _c;
            let updateProductVariantNames$ = of([]);
            if (input.autoUpdate) {
                // Update any ProductVariants' names which include the option name
                let oldOptionName;
                const newOptionName = (_a = findTranslation(input, languageCode)) === null || _a === void 0 ? void 0 : _a.name;
                if (!newOptionName) {
                    updateProductVariantNames$ = of([]);
                }
                const variantsToUpdate = [];
                for (const variant of variants) {
                    if (variant.options.map(o => o.id).includes(input.id)) {
                        if (!oldOptionName) {
                            oldOptionName = (_b = findTranslation(variant.options.find(o => o.id === input.id), languageCode)) === null || _b === void 0 ? void 0 : _b.name;
                        }
                        const variantName = ((_c = findTranslation(variant, languageCode)) === null || _c === void 0 ? void 0 : _c.name) || '';
                        if (oldOptionName && newOptionName && variantName.includes(oldOptionName)) {
                            variantsToUpdate.push({
                                id: variant.id,
                                translations: [
                                    {
                                        languageCode,
                                        name: replaceLast(variantName, oldOptionName, newOptionName),
                                    },
                                ],
                            });
                        }
                    }
                }
                if (variantsToUpdate.length) {
                    updateProductVariantNames$ =
                        this.dataService.product.updateProductVariants(variantsToUpdate);
                }
            }
            return this.dataService.product
                .updateProductOption(input)
                .pipe(mergeMap(() => updateProductVariantNames$));
        }));
    }
    deleteProductVariant(id, productId) {
        return this.dataService.product.deleteProductVariant(id).pipe(switchMap(result => {
            if (result.deleteProductVariant.result === DeletionResult.DELETED) {
                return this.dataService.product.getProduct(productId).single$;
            }
            else {
                return throwError(result.deleteProductVariant.message);
            }
        }));
    }
}
ProductDetailService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProductDetailService_Factory() { return new ProductDetailService(i0.ɵɵinject(i1.DataService)); }, token: ProductDetailService, providedIn: "root" });
ProductDetailService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
ProductDetailService.ctorParameters = () => [
    { type: DataService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZHVjdC1kZXRhaWwuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvcHJvdmlkZXJzL3Byb2R1Y3QtZGV0YWlsL3Byb2R1Y3QtZGV0YWlsLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBR0gsV0FBVyxFQUNYLGNBQWMsRUFFZCxlQUFlLEdBUWxCLE1BQU0sd0JBQXdCLENBQUM7QUFDaEMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3RFLE9BQU8sRUFBRSxRQUFRLEVBQWMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM1RCxPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFJdkUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFFN0M7OztHQUdHO0FBSUgsTUFBTSxPQUFPLG9CQUFvQjtJQUM3QixZQUFvQixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtJQUFHLENBQUM7SUFFaEQsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0RixDQUFDO0lBRUQsZ0JBQWdCO1FBQ1osT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVE7YUFDM0IsZ0JBQWdCLEVBQUU7YUFDbEIsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFD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QUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQzthQUNqRTtpQkFBTTtnQkFDSCxPQUFPLFVBQVUsQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDMUQ7UUFDTCxDQUFDLENBQUMsQ0FDTCxDQUFDO0lBQ04sQ0FBQzs7OztZQWpRSixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7OztZQTNCRyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gICAgQ3JlYXRlUHJvZHVjdElucHV0LFxyXG4gICAgQ3JlYXRlUHJvZHVjdFZhcmlhbnRJbnB1dCxcclxuICAgIERhdGFTZXJ2aWNlLFxyXG4gICAgRGVsZXRpb25SZXN1bHQsXHJcbiAgICBGYWNldFdpdGhWYWx1ZXMsXHJcbiAgICBmaW5kVHJhbnNsYXRpb24sXHJcbiAgICBHZXRQcm9kdWN0V2l0aFZhcmlhbnRzLFxyXG4gICAgTGFuZ3VhZ2VDb2RlLFxyXG4gICAgVXBkYXRlUHJvZHVjdElucHV0LFxyXG4gICAgVXBkYXRlUHJvZHVjdE11dGF0aW9uLFxyXG4gICAgVXBkYXRlUHJvZHVjdE9wdGlvbklucHV0LFxyXG4gICAgVXBkYXRlUHJvZHVjdFZhcmlhbnRJbnB1dCxcclxuICAgIFVwZGF0ZVByb2R1Y3RWYXJpYW50c011dGF0aW9uLFxyXG59IGZyb20gJ0B2ZW5kdXJlL2FkbWluLXVpL2NvcmUnO1xyXG5pbXBvcnQgeyBub3JtYWxpemVTdHJpbmcgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL25vcm1hbGl6ZS1zdHJpbmcnO1xyXG5pbXBvcnQgeyBub3ROdWxsT3JVbmRlZmluZWQgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC11dGlscyc7XHJcbmltcG9ydCB7IGZvcmtKb2luLCBPYnNlcnZhYmxlLCBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAsIG1lcmdlTWFwLCBzaGFyZVJlcGxheSwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgQ3JlYXRlUHJvZHVjdFZhcmlhbnRzQ29uZmlnIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9nZW5lcmF0ZS1wcm9kdWN0LXZhcmlhbnRzL2dlbmVyYXRlLXByb2R1Y3QtdmFyaWFudHMuY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7IHJlcGxhY2VMYXN0IH0gZnJvbSAnLi9yZXBsYWNlLWxhc3QnO1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgdGhlIGxvZ2ljIGZvciBtYWtpbmcgdGhlIEFQSSBjYWxscyB0byBwZXJmb3JtIENSVUQgb3BlcmF0aW9ucyBvbiBhIFByb2R1Y3QgYW5kIGl0cyByZWxhdGVkXHJcbiAqIGVudGl0aWVzLiBUaGlzIGxvZ2ljIHdhcyBleHRyYWN0ZWQgb3V0IG9mIHRoZSBjb21wb25lbnQgYmVjYXVzZSBpdCBiZWNhbWUgdG9vIGxhcmdlIGFuZCBoYXJkIHRvIGZvbGxvdy5cclxuICovXHJcbkBJbmplY3RhYmxlKHtcclxuICAgIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIFByb2R1Y3REZXRhaWxTZXJ2aWNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlKSB7fVxyXG5cclxuICAgIGdldEZhY2V0cygpOiBPYnNlcnZhYmxlPEZhY2V0V2l0aFZhbHVlcy5GcmFnbWVudFtdPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuZmFjZXQuZ2V0QWxsRmFjZXRzKCkubWFwU2luZ2xlKGRhdGEgPT4gZGF0YS5mYWNldHMuaXRlbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRheENhdGVnb3JpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2Uuc2V0dGluZ3NcclxuICAgICAgICAgICAgLmdldFRheENhdGVnb3JpZXMoKVxyXG4gICAgICAgICAgICAubWFwU2luZ2xlKGRhdGEgPT4gZGF0YS50YXhDYXRlZ29yaWVzKVxyXG4gICAgICAgICAgICAucGlwZShzaGFyZVJlcGxheSgxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlUHJvZHVjdFdpdGhWYXJpYW50cyhcclxuICAgICAgICBpbnB1dDogQ3JlYXRlUHJvZHVjdElucHV0LFxyXG4gICAgICAgIGNyZWF0ZVZhcmlhbnRzQ29uZmlnOiBDcmVhdGVQcm9kdWN0VmFyaWFudHNDb25maWcsXHJcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiBMYW5ndWFnZUNvZGUsXHJcbiAgICApIHtcclxuICAgICAgICBjb25zdCBjcmVhdGVQcm9kdWN0JCA9IHRoaXMuZGF0YVNlcnZpY2UucHJvZHVjdC5jcmVhdGVQcm9kdWN0KGlucHV0KTtcclxuICAgICAgICBjb25zdCBub25FbXB0eU9wdGlvbkdyb3VwcyA9IGNyZWF0ZVZhcmlhbnRzQ29uZmlnLmdyb3Vwcy5maWx0ZXIoZyA9PiAwIDwgZy52YWx1ZXMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBjcmVhdGVPcHRpb25Hcm91cHMkID0gdGhpcy5jcmVhdGVQcm9kdWN0T3B0aW9uR3JvdXBzKG5vbkVtcHR5T3B0aW9uR3JvdXBzLCBsYW5ndWFnZUNvZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oY3JlYXRlUHJvZHVjdCQsIGNyZWF0ZU9wdGlvbkdyb3VwcyQpLnBpcGUoXHJcbiAgICAgICAgICAgIG1lcmdlTWFwKChbeyBjcmVhdGVQcm9kdWN0IH0sIG9wdGlvbkdyb3Vwc10pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZE9wdGlvbnNUb1Byb2R1Y3QkID0gb3B0aW9uR3JvdXBzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgID8gZm9ya0pvaW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uR3JvdXBzLm1hcChvcHRpb25Hcm91cCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLnByb2R1Y3QuYWRkT3B0aW9uR3JvdXBUb1Byb2R1Y3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBjcmVhdGVQcm9kdWN0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uR3JvdXBJZDogb3B0aW9uR3JvdXAuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgIDogb2YoW10pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZE9wdGlvbnNUb1Byb2R1Y3QkLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY3JlYXRlUHJvZHVjdCwgb3B0aW9uR3JvdXBzIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgbWVyZ2VNYXAoKHsgY3JlYXRlUHJvZHVjdCwgb3B0aW9uR3JvdXBzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRzID0gY3JlYXRlVmFyaWFudHNDb25maWcudmFyaWFudHMubWFwKHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbklkcyA9IG9wdGlvbkdyb3Vwcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2Lm9wdGlvblZhbHVlcy5tYXAoKG9wdGlvbk5hbWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbkdyb3Vwc1tpbmRleF0ub3B0aW9ucy5maW5kKG8gPT4gby5uYW1lID09PSBvcHRpb25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyBQcm9kdWN0T3B0aW9uIFwiJHtvcHRpb25OYW1lfVwiIHdoZW4gY3JlYXRpbmcgdmFyaWFudGAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi52LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25JZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbkdyb3Vwcy5tYXAob2cgPT4gb2cub3B0aW9ucykucmVkdWNlKChmbGF0LCBvKSA9PiBbLi4uZmxhdCwgLi4ub10sIFtdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb2R1Y3RWYXJpYW50cyhjcmVhdGVQcm9kdWN0LCB2YXJpYW50cywgb3B0aW9ucywgbGFuZ3VhZ2VDb2RlKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVQcm9kdWN0T3B0aW9uR3JvdXBzKGdyb3VwczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHZhbHVlczogc3RyaW5nW10gfT4sIGxhbmd1YWdlQ29kZTogTGFuZ3VhZ2VDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGdyb3Vwcy5sZW5ndGhcclxuICAgICAgICAgICAgPyBmb3JrSm9pbihcclxuICAgICAgICAgICAgICAgICAgZ3JvdXBzLm1hcChjID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLnByb2R1Y3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlUHJvZHVjdE9wdGlvbkdyb3Vwcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IG5vcm1hbGl6ZVN0cmluZyhjLm5hbWUsICctJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uczogW3sgbGFuZ3VhZ2VDb2RlLCBuYW1lOiBjLm5hbWUgfV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGMudmFsdWVzLm1hcCh2ID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBub3JtYWxpemVTdHJpbmcodiwgJy0nKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uczogW3sgbGFuZ3VhZ2VDb2RlLCBuYW1lOiB2IH1dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAucGlwZShtYXAoZGF0YSA9PiBkYXRhLmNyZWF0ZVByb2R1Y3RPcHRpb25Hcm91cCkpO1xyXG4gICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIDogb2YoW10pO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVByb2R1Y3RWYXJpYW50cyhcclxuICAgICAgICBwcm9kdWN0OiB7IG5hbWU6IHN0cmluZzsgaWQ6IHN0cmluZyB9LFxyXG4gICAgICAgIHZhcmlhbnREYXRhOiBBcnJheTx7IHByaWNlOiBudW1iZXI7IHNrdTogc3RyaW5nOyBzdG9jazogbnVtYmVyOyBvcHRpb25JZHM6IHN0cmluZ1tdIH0+LFxyXG4gICAgICAgIG9wdGlvbnM6IEFycmF5PHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH0+LFxyXG4gICAgICAgIGxhbmd1YWdlQ29kZTogTGFuZ3VhZ2VDb2RlLFxyXG4gICAgKSB7XHJcbiAgICAgICAgY29uc3QgdmFyaWFudHM6IENyZWF0ZVByb2R1Y3RWYXJpYW50SW5wdXRbXSA9IHZhcmlhbnREYXRhLm1hcCh2ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG9wdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA/IGAke3Byb2R1Y3QubmFtZX0gJHt2Lm9wdGlvbklkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChpZCA9PiBvcHRpb25zLmZpbmQobyA9PiBvLmlkID09PSBpZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG5vdE51bGxPclVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAobyA9PiBvLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbignICcpfWBcclxuICAgICAgICAgICAgICAgIDogcHJvZHVjdC5uYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0LmlkLFxyXG4gICAgICAgICAgICAgICAgcHJpY2U6IHYucHJpY2UsXHJcbiAgICAgICAgICAgICAgICBza3U6IHYuc2t1LFxyXG4gICAgICAgICAgICAgICAgc3RvY2tPbkhhbmQ6IHYuc3RvY2ssXHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbklkczogdi5vcHRpb25JZHMsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UucHJvZHVjdC5jcmVhdGVQcm9kdWN0VmFyaWFudHModmFyaWFudHMpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoeyBjcmVhdGVQcm9kdWN0VmFyaWFudHMgfSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVByb2R1Y3RWYXJpYW50cyxcclxuICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdC5pZCxcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlUHJvZHVjdCh1cGRhdGVPcHRpb25zOiB7XHJcbiAgICAgICAgcHJvZHVjdDogR2V0UHJvZHVjdFdpdGhWYXJpYW50cy5Qcm9kdWN0O1xyXG4gICAgICAgIGxhbmd1YWdlQ29kZTogTGFuZ3VhZ2VDb2RlO1xyXG4gICAgICAgIGF1dG9VcGRhdGU6IGJvb2xlYW47XHJcbiAgICAgICAgcHJvZHVjdElucHV0PzogVXBkYXRlUHJvZHVjdElucHV0O1xyXG4gICAgICAgIHZhcmlhbnRzSW5wdXQ/OiBVcGRhdGVQcm9kdWN0VmFyaWFudElucHV0W107XHJcbiAgICB9KSB7XHJcbiAgICAgICAgY29uc3QgeyBwcm9kdWN0LCBsYW5ndWFnZUNvZGUsIGF1dG9VcGRhdGUsIHByb2R1Y3RJbnB1dCwgdmFyaWFudHNJbnB1dCB9ID0gdXBkYXRlT3B0aW9ucztcclxuICAgICAgICBjb25zdCB1cGRhdGVPcGVyYXRpb25zOiBBcnJheTxPYnNlcnZhYmxlPFVwZGF0ZVByb2R1Y3RNdXRhdGlvbiB8IFVwZGF0ZVByb2R1Y3RWYXJpYW50c011dGF0aW9uPj4gPSBbXTtcclxuICAgICAgICBjb25zdCB1cGRhdGVWYXJpYW50c0lucHV0ID0gdmFyaWFudHNJbnB1dCB8fCBbXTtcclxuXHJcbiAgICAgICAgY29uc3QgdmFyaWFudHMkID0gYXV0b1VwZGF0ZVxyXG4gICAgICAgICAgICA/IHRoaXMuZGF0YVNlcnZpY2UucHJvZHVjdFxyXG4gICAgICAgICAgICAgICAgICAuZ2V0UHJvZHVjdFZhcmlhbnRzKHt9LCBwcm9kdWN0LmlkKVxyXG4gICAgICAgICAgICAgICAgICAubWFwU2luZ2xlKCh7IHByb2R1Y3RWYXJpYW50cyB9KSA9PiBwcm9kdWN0VmFyaWFudHMuaXRlbXMpXHJcbiAgICAgICAgICAgIDogb2YoW10pO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFyaWFudHMkLnBpcGUoXHJcbiAgICAgICAgICAgIG1lcmdlTWFwKHZhcmlhbnRzID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9kdWN0SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPcGVyYXRpb25zLnB1c2godGhpcy5kYXRhU2VydmljZS5wcm9kdWN0LnVwZGF0ZVByb2R1Y3QocHJvZHVjdElucHV0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjdE9sZE5hbWUgPSBmaW5kVHJhbnNsYXRpb24ocHJvZHVjdCwgbGFuZ3VhZ2VDb2RlKT8ubmFtZSA/PyAnJztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0TmV3TmFtZSA9IGZpbmRUcmFuc2xhdGlvbihwcm9kdWN0SW5wdXQsIGxhbmd1YWdlQ29kZSk/Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2R1Y3ROZXdOYW1lICYmIHByb2R1Y3RPbGROYW1lICE9PSBwcm9kdWN0TmV3TmFtZSAmJiBhdXRvVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFyaWFudCBvZiB2YXJpYW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhcmlhbnROYW1lID0gZmluZFRyYW5zbGF0aW9uKHZhcmlhbnQsIGxhbmd1YWdlQ29kZSk/Lm5hbWUgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFyaWFudElucHV0OiBVcGRhdGVQcm9kdWN0VmFyaWFudElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYXJpYW50SW5wdXQgPSB1cGRhdGVWYXJpYW50c0lucHV0LmZpbmQoaSA9PiBpLmlkID09PSB2YXJpYW50LmlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1ZhcmlhbnRJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnRJbnB1dCA9IGV4aXN0aW5nVmFyaWFudElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50SW5wdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB2YXJpYW50LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbnM6IFt7IGxhbmd1YWdlQ29kZSwgbmFtZTogY3VycmVudFZhcmlhbnROYW1lIH1dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFyaWFudHNJbnB1dC5wdXNoKHZhcmlhbnRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW50VHJhbnNsYXRpb24gPSBmaW5kVHJhbnNsYXRpb24odmFyaWFudElucHV0LCBsYW5ndWFnZUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhbnRUcmFuc2xhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYW50VHJhbnNsYXRpb24ubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50VHJhbnNsYXRpb24ubmFtZSA9IHJlcGxhY2VMYXN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudFRyYW5zbGF0aW9uLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0T2xkTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3ROZXdOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YXJpYW50IHRyYW5zbGF0aW9uIHdhcyBmYWxzeSwgd2hpY2ggb2NjdXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gZGVmaW5pbmcgdGhlIHByb2R1Y3QgbmFtZSBmb3IgYSBuZXcgdHJhbnNsYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGFuZ3VhZ2UgdGhhdCBoYWQgbm90IHlldCBiZWVuIGRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnRUcmFuc2xhdGlvbi5uYW1lID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdE5ld05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YXJpYW50Lm9wdGlvbnMubWFwKG8gPT4gby5uYW1lKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVZhcmlhbnRzSW5wdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlT3BlcmF0aW9ucy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLnByb2R1Y3QudXBkYXRlUHJvZHVjdFZhcmlhbnRzKHVwZGF0ZVZhcmlhbnRzSW5wdXQpLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ya0pvaW4odXBkYXRlT3BlcmF0aW9ucyk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlUHJvZHVjdE9wdGlvbihcclxuICAgICAgICBpbnB1dDogVXBkYXRlUHJvZHVjdE9wdGlvbklucHV0ICYgeyBhdXRvVXBkYXRlOiBib29sZWFuIH0sXHJcbiAgICAgICAgcHJvZHVjdDogR2V0UHJvZHVjdFdpdGhWYXJpYW50cy5Qcm9kdWN0LFxyXG4gICAgICAgIGxhbmd1YWdlQ29kZTogTGFuZ3VhZ2VDb2RlLFxyXG4gICAgKSB7XHJcbiAgICAgICAgY29uc3QgdmFyaWFudHMkID0gaW5wdXQuYXV0b1VwZGF0ZVxyXG4gICAgICAgICAgICA/IHRoaXMuZGF0YVNlcnZpY2UucHJvZHVjdFxyXG4gICAgICAgICAgICAgICAgICAuZ2V0UHJvZHVjdFZhcmlhbnRzKHt9LCBwcm9kdWN0LmlkKVxyXG4gICAgICAgICAgICAgICAgICAubWFwU2luZ2xlKCh7IHByb2R1Y3RWYXJpYW50cyB9KSA9PiBwcm9kdWN0VmFyaWFudHMuaXRlbXMpXHJcbiAgICAgICAgICAgIDogb2YoW10pO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFyaWFudHMkLnBpcGUoXHJcbiAgICAgICAgICAgIG1lcmdlTWFwKHZhcmlhbnRzID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVQcm9kdWN0VmFyaWFudE5hbWVzJDogT2JzZXJ2YWJsZTxhbnk+ID0gb2YoW10pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmF1dG9VcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYW55IFByb2R1Y3RWYXJpYW50cycgbmFtZXMgd2hpY2ggaW5jbHVkZSB0aGUgb3B0aW9uIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkT3B0aW9uTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbk5hbWUgPSBmaW5kVHJhbnNsYXRpb24oaW5wdXQsIGxhbmd1YWdlQ29kZSk/Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdPcHRpb25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVByb2R1Y3RWYXJpYW50TmFtZXMkID0gb2YoW10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW50c1RvVXBkYXRlOiBVcGRhdGVQcm9kdWN0VmFyaWFudElucHV0W10gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhcmlhbnQgb2YgdmFyaWFudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhbnQub3B0aW9ucy5tYXAobyA9PiBvLmlkKS5pbmNsdWRlcyhpbnB1dC5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkT3B0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZE9wdGlvbk5hbWUgPSBmaW5kVHJhbnNsYXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQub3B0aW9ucy5maW5kKG8gPT4gby5pZCA9PT0gaW5wdXQuaWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZUNvZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKT8ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnROYW1lID0gZmluZFRyYW5zbGF0aW9uKHZhcmlhbnQsIGxhbmd1YWdlQ29kZSk/Lm5hbWUgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkT3B0aW9uTmFtZSAmJiBuZXdPcHRpb25OYW1lICYmIHZhcmlhbnROYW1lLmluY2x1ZGVzKG9sZE9wdGlvbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudHNUb1VwZGF0ZS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHZhcmlhbnQuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByZXBsYWNlTGFzdCh2YXJpYW50TmFtZSwgb2xkT3B0aW9uTmFtZSwgbmV3T3B0aW9uTmFtZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYW50c1RvVXBkYXRlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcm9kdWN0VmFyaWFudE5hbWVzJCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLnByb2R1Y3QudXBkYXRlUHJvZHVjdFZhcmlhbnRzKHZhcmlhbnRzVG9VcGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLnByb2R1Y3RcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlUHJvZHVjdE9wdGlvbihpbnB1dClcclxuICAgICAgICAgICAgICAgICAgICAucGlwZShtZXJnZU1hcCgoKSA9PiB1cGRhdGVQcm9kdWN0VmFyaWFudE5hbWVzJCkpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZVByb2R1Y3RWYXJpYW50KGlkOiBzdHJpbmcsIHByb2R1Y3RJZDogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UucHJvZHVjdC5kZWxldGVQcm9kdWN0VmFyaWFudChpZCkucGlwZShcclxuICAgICAgICAgICAgc3dpdGNoTWFwKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRlbGV0ZVByb2R1Y3RWYXJpYW50LnJlc3VsdCA9PT0gRGVsZXRpb25SZXN1bHQuREVMRVRFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLnByb2R1Y3QuZ2V0UHJvZHVjdChwcm9kdWN0SWQpLnNpbmdsZSQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHJlc3VsdC5kZWxldGVQcm9kdWN0VmFyaWFudC5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4iXX0=