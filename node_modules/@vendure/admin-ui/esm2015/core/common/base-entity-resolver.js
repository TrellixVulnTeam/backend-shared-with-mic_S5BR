import { ActivationStart, } from '@angular/router';
import { notNullOrUndefined } from '@vendure/common/lib/shared-utils';
import { of } from 'rxjs';
import { filter, map, shareReplay, take, takeUntil } from 'rxjs/operators';
export function createResolveData(resolver) {
    return {
        entity: resolver,
    };
}
/**
 * @description
 * A base resolver for an entity detail route. Resolves to an observable of the given entity, or a "blank"
 * version if the route id equals "create". Should be used together with details views which extend the
 * {@link BaseDetailComponent}.
 *
 * @example
 * ```TypeScript
 * \@Injectable({
 *   providedIn: 'root',
 * })
 * export class MyEntityResolver extends BaseEntityResolver<MyEntity.Fragment> {
 *   constructor(router: Router, dataService: DataService) {
 *     super(
 *       router,
 *       {
 *         __typename: 'MyEntity',
 *         id: '',
 *         createdAt: '',
 *         updatedAt: '',
 *         name: '',
 *       },
 *       id => dataService.query(GET_MY_ENTITY, { id }).mapStream(data => data.myEntity),
 *     );
 *   }
 * }
 * ```
 *
 * @docsCategory list-detail-views
 */
export class BaseEntityResolver {
    constructor(router, emptyEntity, entityStream) {
        this.router = router;
        this.emptyEntity = emptyEntity;
        this.entityStream = entityStream;
    }
    /** @internal */
    resolve(route, state) {
        const id = route.paramMap.get('id');
        // Complete the entity stream upon navigating away
        const navigateAway$ = this.router.events.pipe(filter(event => event instanceof ActivationStart));
        if (id === 'create') {
            return of(of(this.emptyEntity));
        }
        else {
            const stream = this.entityStream(id || '').pipe(takeUntil(navigateAway$), filter(notNullOrUndefined), shareReplay(1));
            return stream.pipe(take(1), map(() => stream));
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1lbnRpdHktcmVzb2x2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL2NvbW1vbi9iYXNlLWVudGl0eS1yZXNvbHZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsZUFBZSxHQUtsQixNQUFNLGlCQUFpQixDQUFDO0FBRXpCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3RFLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU0zRSxNQUFNLFVBQVUsaUJBQWlCLENBQzdCLFFBQWlCO0lBRWpCLE9BQU87UUFDSCxNQUFNLEVBQUUsUUFBUTtLQUNuQixDQUFDO0FBQ04sQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCRztBQUNILE1BQU0sT0FBTyxrQkFBa0I7SUFDM0IsWUFDYyxNQUFjLEVBQ1AsV0FBYyxFQUN2QixZQUE4RDtRQUY1RCxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ1AsZ0JBQVcsR0FBWCxXQUFXLENBQUc7UUFDdkIsaUJBQVksR0FBWixZQUFZLENBQWtEO0lBQ3ZFLENBQUM7SUFFSixnQkFBZ0I7SUFDaEIsT0FBTyxDQUFDLEtBQTZCLEVBQUUsS0FBMEI7UUFDN0QsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFcEMsa0RBQWtEO1FBQ2xELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLFlBQVksZUFBZSxDQUFDLENBQUMsQ0FBQztRQUVqRyxJQUFJLEVBQUUsS0FBSyxRQUFRLEVBQUU7WUFDakIsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1NBQ25DO2FBQU07WUFDSCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQzNDLFNBQVMsQ0FBQyxhQUFhLENBQUMsRUFDeEIsTUFBTSxDQUFDLGtCQUFrQixDQUFDLEVBQzFCLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FDakIsQ0FBQztZQUVGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FDZCxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQ1AsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUNwQixDQUFDO1NBQ0w7SUFDTCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCxcclxuICAgIEFjdGl2YXRpb25TdGFydCxcclxuICAgIFJlc29sdmUsXHJcbiAgICBSZXNvbHZlRGF0YSxcclxuICAgIFJvdXRlcixcclxuICAgIFJvdXRlclN0YXRlU25hcHNob3QsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0B2ZW5kdXJlL2NvbW1vbi9saWIvc2hhcmVkLXR5cGVzJztcclxuaW1wb3J0IHsgbm90TnVsbE9yVW5kZWZpbmVkIH0gZnJvbSAnQHZlbmR1cmUvY29tbW9uL2xpYi9zaGFyZWQtdXRpbHMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgc2hhcmVSZXBsYXksIHRha2UsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5UmVzb2x2ZURhdGE8Uj4gZXh0ZW5kcyBSZXNvbHZlRGF0YSB7XHJcbiAgICBlbnRpdHk6IFR5cGU8QmFzZUVudGl0eVJlc29sdmVyPFI+PjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVEYXRhPFQgZXh0ZW5kcyBCYXNlRW50aXR5UmVzb2x2ZXI8Uj4sIFI+KFxyXG4gICAgcmVzb2x2ZXI6IFR5cGU8VD4sXHJcbik6IEVudGl0eVJlc29sdmVEYXRhPFI+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZW50aXR5OiByZXNvbHZlcixcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBiYXNlIHJlc29sdmVyIGZvciBhbiBlbnRpdHkgZGV0YWlsIHJvdXRlLiBSZXNvbHZlcyB0byBhbiBvYnNlcnZhYmxlIG9mIHRoZSBnaXZlbiBlbnRpdHksIG9yIGEgXCJibGFua1wiXHJcbiAqIHZlcnNpb24gaWYgdGhlIHJvdXRlIGlkIGVxdWFscyBcImNyZWF0ZVwiLiBTaG91bGQgYmUgdXNlZCB0b2dldGhlciB3aXRoIGRldGFpbHMgdmlld3Mgd2hpY2ggZXh0ZW5kIHRoZVxyXG4gKiB7QGxpbmsgQmFzZURldGFpbENvbXBvbmVudH0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYFR5cGVTY3JpcHRcclxuICogXFxASW5qZWN0YWJsZSh7XHJcbiAqICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgTXlFbnRpdHlSZXNvbHZlciBleHRlbmRzIEJhc2VFbnRpdHlSZXNvbHZlcjxNeUVudGl0eS5GcmFnbWVudD4ge1xyXG4gKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogUm91dGVyLCBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UpIHtcclxuICogICAgIHN1cGVyKFxyXG4gKiAgICAgICByb3V0ZXIsXHJcbiAqICAgICAgIHtcclxuICogICAgICAgICBfX3R5cGVuYW1lOiAnTXlFbnRpdHknLFxyXG4gKiAgICAgICAgIGlkOiAnJyxcclxuICogICAgICAgICBjcmVhdGVkQXQ6ICcnLFxyXG4gKiAgICAgICAgIHVwZGF0ZWRBdDogJycsXHJcbiAqICAgICAgICAgbmFtZTogJycsXHJcbiAqICAgICAgIH0sXHJcbiAqICAgICAgIGlkID0+IGRhdGFTZXJ2aWNlLnF1ZXJ5KEdFVF9NWV9FTlRJVFksIHsgaWQgfSkubWFwU3RyZWFtKGRhdGEgPT4gZGF0YS5teUVudGl0eSksXHJcbiAqICAgICApO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQGRvY3NDYXRlZ29yeSBsaXN0LWRldGFpbC12aWV3c1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJhc2VFbnRpdHlSZXNvbHZlcjxUPiBpbXBsZW1lbnRzIFJlc29sdmU8T2JzZXJ2YWJsZTxUPj4ge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJvdGVjdGVkIHJvdXRlcjogUm91dGVyLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgZW1wdHlFbnRpdHk6IFQsXHJcbiAgICAgICAgcHJpdmF0ZSBlbnRpdHlTdHJlYW06IChpZDogc3RyaW5nKSA9PiBPYnNlcnZhYmxlPFQgfCBudWxsIHwgdW5kZWZpbmVkPixcclxuICAgICkge31cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICByZXNvbHZlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBzdGF0ZTogUm91dGVyU3RhdGVTbmFwc2hvdCk6IE9ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj4ge1xyXG4gICAgICAgIGNvbnN0IGlkID0gcm91dGUucGFyYW1NYXAuZ2V0KCdpZCcpO1xyXG5cclxuICAgICAgICAvLyBDb21wbGV0ZSB0aGUgZW50aXR5IHN0cmVhbSB1cG9uIG5hdmlnYXRpbmcgYXdheVxyXG4gICAgICAgIGNvbnN0IG5hdmlnYXRlQXdheSQgPSB0aGlzLnJvdXRlci5ldmVudHMucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBBY3RpdmF0aW9uU3RhcnQpKTtcclxuXHJcbiAgICAgICAgaWYgKGlkID09PSAnY3JlYXRlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gb2Yob2YodGhpcy5lbXB0eUVudGl0eSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuZW50aXR5U3RyZWFtKGlkIHx8ICcnKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKG5hdmlnYXRlQXdheSQpLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyKG5vdE51bGxPclVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICBzaGFyZVJlcGxheSgxKSxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0ucGlwZShcclxuICAgICAgICAgICAgICAgIHRha2UoMSksXHJcbiAgICAgICAgICAgICAgICBtYXAoKCkgPT4gc3RyZWFtKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19