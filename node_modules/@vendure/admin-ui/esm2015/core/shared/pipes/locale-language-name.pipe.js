import { ChangeDetectorRef, Optional, Pipe } from '@angular/core';
import { DataService } from '../../data/providers/data.service';
import { LocaleBasePipe } from './locale-base.pipe';
/**
 * @description
 * Displays a human-readable name for a given ISO 639-1 language code.
 *
 * @example
 * ```HTML
 * {{ 'zh_Hant' | localeLanguageName }}
 * ```
 *
 * @docsCategory pipes
 */
export class LocaleLanguageNamePipe extends LocaleBasePipe {
    constructor(dataService, changeDetectorRef) {
        super(dataService, changeDetectorRef);
    }
    transform(value, locale) {
        if (value == null || value === '') {
            return '';
        }
        if (typeof value !== 'string') {
            return `Invalid language code "${value}"`;
        }
        const activeLocale = this.getActiveLocale(locale);
        // Awaiting TS types for this API: https://github.com/microsoft/TypeScript/pull/44022/files
        const DisplayNames = Intl.DisplayNames;
        try {
            return new DisplayNames([activeLocale.replace('_', '-')], { type: 'language' }).of(value.replace('_', '-'));
        }
        catch (e) {
            return value;
        }
    }
}
LocaleLanguageNamePipe.decorators = [
    { type: Pipe, args: [{
                name: 'localeLanguageName',
                pure: false,
            },] }
];
LocaleLanguageNamePipe.ctorParameters = () => [
    { type: DataService, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef, decorators: [{ type: Optional }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxlLWxhbmd1YWdlLW5hbWUucGlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29yZS9zcmMvc2hhcmVkL3BpcGVzL2xvY2FsZS1sYW5ndWFnZS1uYW1lLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRWpGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUVoRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFcEQ7Ozs7Ozs7Ozs7R0FVRztBQUtILE1BQU0sT0FBTyxzQkFBdUIsU0FBUSxjQUFjO0lBQ3RELFlBQXdCLFdBQXlCLEVBQWMsaUJBQXFDO1FBQ2hHLEtBQUssQ0FBQyxXQUFXLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBQ0QsU0FBUyxDQUFDLEtBQVUsRUFBRSxNQUFnQjtRQUNsQyxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUUsRUFBRTtZQUMvQixPQUFPLEVBQUUsQ0FBQztTQUNiO1FBQ0QsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDM0IsT0FBTywwQkFBMEIsS0FBWSxHQUFHLENBQUM7U0FDcEQ7UUFDRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWxELDJGQUEyRjtRQUMzRixNQUFNLFlBQVksR0FBSSxJQUFZLENBQUMsWUFBWSxDQUFDO1FBRWhELElBQUk7WUFDQSxPQUFPLElBQUksWUFBWSxDQUFDLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FDOUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQzFCLENBQUM7U0FDTDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1IsT0FBTyxLQUFLLENBQUM7U0FDaEI7SUFDTCxDQUFDOzs7WUEzQkosSUFBSSxTQUFDO2dCQUNGLElBQUksRUFBRSxvQkFBb0I7Z0JBQzFCLElBQUksRUFBRSxLQUFLO2FBQ2Q7OztZQWxCUSxXQUFXLHVCQW9CSCxRQUFRO1lBdEJoQixpQkFBaUIsdUJBc0I4QixRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIE9wdGlvbmFsLCBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBEYXRhU2VydmljZSB9IGZyb20gJy4uLy4uL2RhdGEvcHJvdmlkZXJzL2RhdGEuc2VydmljZSc7XHJcblxyXG5pbXBvcnQgeyBMb2NhbGVCYXNlUGlwZSB9IGZyb20gJy4vbG9jYWxlLWJhc2UucGlwZSc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERpc3BsYXlzIGEgaHVtYW4tcmVhZGFibGUgbmFtZSBmb3IgYSBnaXZlbiBJU08gNjM5LTEgbGFuZ3VhZ2UgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgSFRNTFxyXG4gKiB7eyAnemhfSGFudCcgfCBsb2NhbGVMYW5ndWFnZU5hbWUgfX1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgcGlwZXNcclxuICovXHJcbkBQaXBlKHtcclxuICAgIG5hbWU6ICdsb2NhbGVMYW5ndWFnZU5hbWUnLFxyXG4gICAgcHVyZTogZmFsc2UsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBMb2NhbGVMYW5ndWFnZU5hbWVQaXBlIGV4dGVuZHMgTG9jYWxlQmFzZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIGRhdGFTZXJ2aWNlPzogRGF0YVNlcnZpY2UsIEBPcHRpb25hbCgpIGNoYW5nZURldGVjdG9yUmVmPzogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcclxuICAgICAgICBzdXBlcihkYXRhU2VydmljZSwgY2hhbmdlRGV0ZWN0b3JSZWYpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIGxvY2FsZT86IHVua25vd24pOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBsYW5ndWFnZSBjb2RlIFwiJHt2YWx1ZSBhcyBhbnl9XCJgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY3RpdmVMb2NhbGUgPSB0aGlzLmdldEFjdGl2ZUxvY2FsZShsb2NhbGUpO1xyXG5cclxuICAgICAgICAvLyBBd2FpdGluZyBUUyB0eXBlcyBmb3IgdGhpcyBBUEk6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzQ0MDIyL2ZpbGVzXHJcbiAgICAgICAgY29uc3QgRGlzcGxheU5hbWVzID0gKEludGwgYXMgYW55KS5EaXNwbGF5TmFtZXM7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlzcGxheU5hbWVzKFthY3RpdmVMb2NhbGUucmVwbGFjZSgnXycsICctJyldLCB7IHR5cGU6ICdsYW5ndWFnZScgfSkub2YoXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5yZXBsYWNlKCdfJywgJy0nKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19