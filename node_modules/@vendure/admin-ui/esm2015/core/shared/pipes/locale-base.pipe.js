import { ChangeDetectorRef, Injectable } from '@angular/core';
import { DataService } from '../../data/providers/data.service';
/**
 * Used by locale-aware pipes to handle the task of getting the active languageCode
 * of the UI and cleaning up.
 */
export class LocaleBasePipe {
    constructor(dataService, changeDetectorRef) {
        if (dataService && changeDetectorRef) {
            this.subscription = dataService.client
                .uiState()
                .mapStream(data => data.uiState)
                .subscribe(({ language, locale }) => {
                this.locale = language.replace(/_/g, '-');
                if (locale) {
                    this.locale += `-${locale}`;
                }
                changeDetectorRef.markForCheck();
            });
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    /**
     * Returns the active locale after attempting to ensure that the locale string
     * is valid for the Intl API.
     */
    getActiveLocale(localeOverride) {
        var _a;
        const locale = typeof localeOverride === 'string' ? localeOverride : (_a = this.locale) !== null && _a !== void 0 ? _a : 'en';
        const hyphenated = locale === null || locale === void 0 ? void 0 : locale.replace(/_/g, '-');
        // Check for a double-region string, containing 2 region codes like
        // pt-BR-BR, which is invalid. In this case, the second region is used
        // and the first region discarded. This would only ever be an issue for
        // those languages where the translation file itself encodes the region,
        // as in pt_BR & pt_PT.
        const matches = hyphenated === null || hyphenated === void 0 ? void 0 : hyphenated.match(/^([a-zA-Z_-]+)(-[A-Z][A-Z])(-[A-Z][A-z])$/);
        if (matches === null || matches === void 0 ? void 0 : matches.length) {
            const overriddenLocale = matches[1] + matches[3];
            return overriddenLocale;
        }
        else {
            return hyphenated;
        }
    }
}
LocaleBasePipe.decorators = [
    { type: Injectable }
];
LocaleBasePipe.ctorParameters = () => [
    { type: DataService },
    { type: ChangeDetectorRef }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxlLWJhc2UucGlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29yZS9zcmMvc2hhcmVkL3BpcGVzL2xvY2FsZS1iYXNlLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFVBQVUsRUFBNEIsTUFBTSxlQUFlLENBQUM7QUFHeEYsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBRWhFOzs7R0FHRztBQUVILE1BQU0sT0FBZ0IsY0FBYztJQUloQyxZQUFzQixXQUF5QixFQUFFLGlCQUFxQztRQUNsRixJQUFJLFdBQVcsSUFBSSxpQkFBaUIsRUFBRTtZQUNsQyxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQyxNQUFNO2lCQUNqQyxPQUFPLEVBQUU7aUJBQ1QsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztpQkFDL0IsU0FBUyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRTtnQkFDaEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDMUMsSUFBSSxNQUFNLEVBQUU7b0JBQ1IsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLE1BQU0sRUFBRSxDQUFDO2lCQUMvQjtnQkFDRCxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUNyQyxDQUFDLENBQUMsQ0FBQztTQUNWO0lBQ0wsQ0FBQztJQUVELFdBQVc7UUFDUCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNuQztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDTyxlQUFlLENBQUMsY0FBd0I7O1FBQzlDLE1BQU0sTUFBTSxHQUFHLE9BQU8sY0FBYyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFBLElBQUksQ0FBQyxNQUFNLG1DQUFJLElBQUksQ0FBQztRQUN6RixNQUFNLFVBQVUsR0FBRyxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztRQUU5QyxtRUFBbUU7UUFDbkUsc0VBQXNFO1FBQ3RFLHVFQUF1RTtRQUN2RSx3RUFBd0U7UUFDeEUsdUJBQXVCO1FBQ3ZCLE1BQU0sT0FBTyxHQUFHLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQztRQUMvRSxJQUFJLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxNQUFNLEVBQUU7WUFDakIsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pELE9BQU8sZ0JBQWdCLENBQUM7U0FDM0I7YUFBTTtZQUNILE9BQU8sVUFBVSxDQUFDO1NBQ3JCO0lBQ0wsQ0FBQzs7O1lBOUNKLFVBQVU7OztZQU5GLFdBQVc7WUFIWCxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgSW5qZWN0YWJsZSwgT25EZXN0cm95LCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi9kYXRhL3Byb3ZpZGVycy9kYXRhLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgYnkgbG9jYWxlLWF3YXJlIHBpcGVzIHRvIGhhbmRsZSB0aGUgdGFzayBvZiBnZXR0aW5nIHRoZSBhY3RpdmUgbGFuZ3VhZ2VDb2RlXHJcbiAqIG9mIHRoZSBVSSBhbmQgY2xlYW5pbmcgdXAuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMb2NhbGVCYXNlUGlwZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgUGlwZVRyYW5zZm9ybSB7XHJcbiAgICBwcm90ZWN0ZWQgbG9jYWxlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihkYXRhU2VydmljZT86IERhdGFTZXJ2aWNlLCBjaGFuZ2VEZXRlY3RvclJlZj86IENoYW5nZURldGVjdG9yUmVmKSB7XHJcbiAgICAgICAgaWYgKGRhdGFTZXJ2aWNlICYmIGNoYW5nZURldGVjdG9yUmVmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gZGF0YVNlcnZpY2UuY2xpZW50XHJcbiAgICAgICAgICAgICAgICAudWlTdGF0ZSgpXHJcbiAgICAgICAgICAgICAgICAubWFwU3RyZWFtKGRhdGEgPT4gZGF0YS51aVN0YXRlKVxyXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoeyBsYW5ndWFnZSwgbG9jYWxlIH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxhbmd1YWdlLnJlcGxhY2UoL18vZywgJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlICs9IGAtJHtsb2NhbGV9YDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYWN0aXZlIGxvY2FsZSBhZnRlciBhdHRlbXB0aW5nIHRvIGVuc3VyZSB0aGF0IHRoZSBsb2NhbGUgc3RyaW5nXHJcbiAgICAgKiBpcyB2YWxpZCBmb3IgdGhlIEludGwgQVBJLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0QWN0aXZlTG9jYWxlKGxvY2FsZU92ZXJyaWRlPzogdW5rbm93bik6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdHlwZW9mIGxvY2FsZU92ZXJyaWRlID09PSAnc3RyaW5nJyA/IGxvY2FsZU92ZXJyaWRlIDogdGhpcy5sb2NhbGUgPz8gJ2VuJztcclxuICAgICAgICBjb25zdCBoeXBoZW5hdGVkID0gbG9jYWxlPy5yZXBsYWNlKC9fL2csICctJyk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGZvciBhIGRvdWJsZS1yZWdpb24gc3RyaW5nLCBjb250YWluaW5nIDIgcmVnaW9uIGNvZGVzIGxpa2VcclxuICAgICAgICAvLyBwdC1CUi1CUiwgd2hpY2ggaXMgaW52YWxpZC4gSW4gdGhpcyBjYXNlLCB0aGUgc2Vjb25kIHJlZ2lvbiBpcyB1c2VkXHJcbiAgICAgICAgLy8gYW5kIHRoZSBmaXJzdCByZWdpb24gZGlzY2FyZGVkLiBUaGlzIHdvdWxkIG9ubHkgZXZlciBiZSBhbiBpc3N1ZSBmb3JcclxuICAgICAgICAvLyB0aG9zZSBsYW5ndWFnZXMgd2hlcmUgdGhlIHRyYW5zbGF0aW9uIGZpbGUgaXRzZWxmIGVuY29kZXMgdGhlIHJlZ2lvbixcclxuICAgICAgICAvLyBhcyBpbiBwdF9CUiAmIHB0X1BULlxyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBoeXBoZW5hdGVkPy5tYXRjaCgvXihbYS16QS1aXy1dKykoLVtBLVpdW0EtWl0pKC1bQS1aXVtBLXpdKSQvKTtcclxuICAgICAgICBpZiAobWF0Y2hlcz8ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRkZW5Mb2NhbGUgPSBtYXRjaGVzWzFdICsgbWF0Y2hlc1szXTtcclxuICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRkZW5Mb2NhbGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGh5cGhlbmF0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFic3RyYWN0IHRyYW5zZm9ybSh2YWx1ZTogYW55LCAuLi5hcmdzKTogYW55O1xyXG59XHJcbiJdfQ==