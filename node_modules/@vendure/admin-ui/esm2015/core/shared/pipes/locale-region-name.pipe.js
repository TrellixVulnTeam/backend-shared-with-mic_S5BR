import { ChangeDetectorRef, Optional, Pipe } from '@angular/core';
import { DataService } from '../../data/providers/data.service';
import { LocaleBasePipe } from './locale-base.pipe';
/**
 * @description
 * Displays a human-readable name for a given region.
 *
 * @example
 * ```HTML
 * {{ 'GB' | localeRegionName }}
 * ```
 *
 * @docsCategory pipes
 */
export class LocaleRegionNamePipe extends LocaleBasePipe {
    constructor(dataService, changeDetectorRef) {
        super(dataService, changeDetectorRef);
    }
    transform(value, locale) {
        if (value == null || value === '') {
            return '';
        }
        if (typeof value !== 'string') {
            return `Invalid region code "${value}"`;
        }
        const activeLocale = this.getActiveLocale(locale);
        // Awaiting TS types for this API: https://github.com/microsoft/TypeScript/pull/44022/files
        const DisplayNames = Intl.DisplayNames;
        try {
            return new DisplayNames([activeLocale.replace('_', '-')], { type: 'region' }).of(value.replace('_', '-'));
        }
        catch (e) {
            return value;
        }
    }
}
LocaleRegionNamePipe.decorators = [
    { type: Pipe, args: [{
                name: 'localeRegionName',
                pure: false,
            },] }
];
LocaleRegionNamePipe.ctorParameters = () => [
    { type: DataService, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef, decorators: [{ type: Optional }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxlLXJlZ2lvbi1uYW1lLnBpcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9waXBlcy9sb2NhbGUtcmVnaW9uLW5hbWUucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFFakYsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBRWhFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVwRDs7Ozs7Ozs7OztHQVVHO0FBS0gsTUFBTSxPQUFPLG9CQUFxQixTQUFRLGNBQWM7SUFDcEQsWUFBd0IsV0FBeUIsRUFBYyxpQkFBcUM7UUFDaEcsS0FBSyxDQUFDLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFDRCxTQUFTLENBQUMsS0FBVSxFQUFFLE1BQWdCO1FBQ2xDLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLEtBQUssRUFBRSxFQUFFO1lBQy9CLE9BQU8sRUFBRSxDQUFDO1NBQ2I7UUFDRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUMzQixPQUFPLHdCQUF3QixLQUFZLEdBQUcsQ0FBQztTQUNsRDtRQUNELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbEQsMkZBQTJGO1FBQzNGLE1BQU0sWUFBWSxHQUFJLElBQVksQ0FBQyxZQUFZLENBQUM7UUFFaEQsSUFBSTtZQUNBLE9BQU8sSUFBSSxZQUFZLENBQUMsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUM1RSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDMUIsQ0FBQztTQUNMO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixPQUFPLEtBQUssQ0FBQztTQUNoQjtJQUNMLENBQUM7OztZQTNCSixJQUFJLFNBQUM7Z0JBQ0YsSUFBSSxFQUFFLGtCQUFrQjtnQkFDeEIsSUFBSSxFQUFFLEtBQUs7YUFDZDs7O1lBbEJRLFdBQVcsdUJBb0JILFFBQVE7WUF0QmhCLGlCQUFpQix1QkFzQjhCLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgT3B0aW9uYWwsIFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGF0YS9wcm92aWRlcnMvZGF0YS5zZXJ2aWNlJztcclxuXHJcbmltcG9ydCB7IExvY2FsZUJhc2VQaXBlIH0gZnJvbSAnLi9sb2NhbGUtYmFzZS5waXBlJztcclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGlzcGxheXMgYSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciBhIGdpdmVuIHJlZ2lvbi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgSFRNTFxyXG4gKiB7eyAnR0InIHwgbG9jYWxlUmVnaW9uTmFtZSB9fVxyXG4gKiBgYGBcclxuICpcclxuICogQGRvY3NDYXRlZ29yeSBwaXBlc1xyXG4gKi9cclxuQFBpcGUoe1xyXG4gICAgbmFtZTogJ2xvY2FsZVJlZ2lvbk5hbWUnLFxyXG4gICAgcHVyZTogZmFsc2UsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBMb2NhbGVSZWdpb25OYW1lUGlwZSBleHRlbmRzIExvY2FsZUJhc2VQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcbiAgICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBkYXRhU2VydmljZT86IERhdGFTZXJ2aWNlLCBAT3B0aW9uYWwoKSBjaGFuZ2VEZXRlY3RvclJlZj86IENoYW5nZURldGVjdG9yUmVmKSB7XHJcbiAgICAgICAgc3VwZXIoZGF0YVNlcnZpY2UsIGNoYW5nZURldGVjdG9yUmVmKTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybSh2YWx1ZTogYW55LCBsb2NhbGU/OiB1bmtub3duKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYEludmFsaWQgcmVnaW9uIGNvZGUgXCIke3ZhbHVlIGFzIGFueX1cImA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUxvY2FsZSA9IHRoaXMuZ2V0QWN0aXZlTG9jYWxlKGxvY2FsZSk7XHJcblxyXG4gICAgICAgIC8vIEF3YWl0aW5nIFRTIHR5cGVzIGZvciB0aGlzIEFQSTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNDQwMjIvZmlsZXNcclxuICAgICAgICBjb25zdCBEaXNwbGF5TmFtZXMgPSAoSW50bCBhcyBhbnkpLkRpc3BsYXlOYW1lcztcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXNwbGF5TmFtZXMoW2FjdGl2ZUxvY2FsZS5yZXBsYWNlKCdfJywgJy0nKV0sIHsgdHlwZTogJ3JlZ2lvbicgfSkub2YoXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5yZXBsYWNlKCdfJywgJy0nKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19