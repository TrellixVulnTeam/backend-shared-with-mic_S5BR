import { ChangeDetectorRef, Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';
import { DEFAULT_CHANNEL_CODE } from '@vendure/common/lib/shared-constants';
import { tap } from 'rxjs/operators';
import { DataService } from '../../data/providers/data.service';
import { IfDirectiveBase } from './if-directive-base';
export class IfDefaultChannelActiveDirective extends IfDirectiveBase {
    constructor(_viewContainer, templateRef, dataService, changeDetectorRef) {
        super(_viewContainer, templateRef, () => {
            return this.dataService.client
                .userStatus()
                .mapStream(({ userStatus }) => this.defaultChannelIsActive(userStatus))
                .pipe(tap(() => this.changeDetectorRef.markForCheck()));
        });
        this.dataService = dataService;
        this.changeDetectorRef = changeDetectorRef;
    }
    /**
     * A template to show if the current user does not have the specified permission.
     */
    set vdrIfMultichannelElse(templateRef) {
        this.setElseTemplate(templateRef);
    }
    defaultChannelIsActive(userStatus) {
        const defaultChannel = userStatus.channels.find(c => c.code === DEFAULT_CHANNEL_CODE);
        return !!(defaultChannel && userStatus.activeChannelId === defaultChannel.id);
    }
}
IfDefaultChannelActiveDirective.decorators = [
    { type: Directive, args: [{
                selector: '[vdrIfDefaultChannelActive]',
            },] }
];
IfDefaultChannelActiveDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: DataService },
    { type: ChangeDetectorRef }
];
IfDefaultChannelActiveDirective.propDecorators = {
    vdrIfMultichannelElse: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWYtZGVmYXVsdC1jaGFubmVsLWFjdGl2ZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9kaXJlY3RpdmVzL2lmLWRlZmF1bHQtY2hhbm5lbC1hY3RpdmUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUM1RSxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHckMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBRWhFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUt0RCxNQUFNLE9BQU8sK0JBQWdDLFNBQVEsZUFBbUI7SUFDcEUsWUFDSSxjQUFnQyxFQUNoQyxXQUE2QixFQUNyQixXQUF3QixFQUN4QixpQkFBb0M7UUFFNUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFO1lBQ3BDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNO2lCQUN6QixVQUFVLEVBQUU7aUJBQ1osU0FBUyxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUN0RSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEUsQ0FBQyxDQUFDLENBQUM7UUFSSyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO0lBUWhELENBQUM7SUFFRDs7T0FFRztJQUNILElBQ0kscUJBQXFCLENBQUMsV0FBb0M7UUFDMUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRU8sc0JBQXNCLENBQUMsVUFBc0I7UUFDakQsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLG9CQUFvQixDQUFDLENBQUM7UUFFdEYsT0FBTyxDQUFDLENBQUMsQ0FBQyxjQUFjLElBQUksVUFBVSxDQUFDLGVBQWUsS0FBSyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDbEYsQ0FBQzs7O1lBOUJKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsNkJBQTZCO2FBQzFDOzs7WUFYMEQsZ0JBQWdCO1lBQTdCLFdBQVc7WUFLaEQsV0FBVztZQUxYLGlCQUFpQjs7O29DQThCckIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIElucHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBERUZBVUxUX0NIQU5ORUxfQ09ERSB9IGZyb20gJ0B2ZW5kdXJlL2NvbW1vbi9saWIvc2hhcmVkLWNvbnN0YW50cyc7XHJcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IFVzZXJTdGF0dXMgfSBmcm9tICcuLi8uLi9jb21tb24vZ2VuZXJhdGVkLXR5cGVzJztcclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi9kYXRhL3Byb3ZpZGVycy9kYXRhLnNlcnZpY2UnO1xyXG5cclxuaW1wb3J0IHsgSWZEaXJlY3RpdmVCYXNlIH0gZnJvbSAnLi9pZi1kaXJlY3RpdmUtYmFzZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW3ZkcklmRGVmYXVsdENoYW5uZWxBY3RpdmVdJyxcclxufSlcclxuZXhwb3J0IGNsYXNzIElmRGVmYXVsdENoYW5uZWxBY3RpdmVEaXJlY3RpdmUgZXh0ZW5kcyBJZkRpcmVjdGl2ZUJhc2U8W10+IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LFxyXG4gICAgICAgIHByaXZhdGUgZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIoX3ZpZXdDb250YWluZXIsIHRlbXBsYXRlUmVmLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmNsaWVudFxyXG4gICAgICAgICAgICAgICAgLnVzZXJTdGF0dXMoKVxyXG4gICAgICAgICAgICAgICAgLm1hcFN0cmVhbSgoeyB1c2VyU3RhdHVzIH0pID0+IHRoaXMuZGVmYXVsdENoYW5uZWxJc0FjdGl2ZSh1c2VyU3RhdHVzKSlcclxuICAgICAgICAgICAgICAgIC5waXBlKHRhcCgoKSA9PiB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHRlbXBsYXRlIHRvIHNob3cgaWYgdGhlIGN1cnJlbnQgdXNlciBkb2VzIG5vdCBoYXZlIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbi5cclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgIHNldCB2ZHJJZk11bHRpY2hhbm5lbEVsc2UodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4gfCBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5zZXRFbHNlVGVtcGxhdGUodGVtcGxhdGVSZWYpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGVmYXVsdENoYW5uZWxJc0FjdGl2ZSh1c2VyU3RhdHVzOiBVc2VyU3RhdHVzKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdENoYW5uZWwgPSB1c2VyU3RhdHVzLmNoYW5uZWxzLmZpbmQoYyA9PiBjLmNvZGUgPT09IERFRkFVTFRfQ0hBTk5FTF9DT0RFKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICEhKGRlZmF1bHRDaGFubmVsICYmIHVzZXJTdGF0dXMuYWN0aXZlQ2hhbm5lbElkID09PSBkZWZhdWx0Q2hhbm5lbC5pZCk7XHJcbiAgICB9XHJcbn1cclxuIl19