"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShippingEligibilityChecker = void 0;
const crypto_1 = require("crypto");
const configurable_operation_1 = require("../../common/configurable-operation");
const ttl_cache_1 = require("../../common/ttl-cache");
class ShippingEligibilityChecker extends configurable_operation_1.ConfigurableOperationDef {
    constructor(config) {
        super(config);
        this.shouldRunCheckCache = new ttl_cache_1.TtlCache({ cacheSize: 5000, ttl: 1000 * 60 * 60 * 5 });
        this.checkFn = config.check;
        this.shouldRunCheckFn = config.shouldRunCheck;
    }
    async check(ctx, order, args) {
        const shouldRunCheck = await this.shouldRunCheck(ctx, order, args);
        return shouldRunCheck ? this.checkFn(ctx, order, this.argsArrayToHash(args)) : true;
    }
    async shouldRunCheck(ctx, order, args) {
        var _a;
        if (typeof this.shouldRunCheckFn === 'function') {
            const cacheKey = (_a = ctx.session) === null || _a === void 0 ? void 0 : _a.id;
            if (cacheKey) {
                const checkResult = await this.shouldRunCheckFn(ctx, order, this.argsArrayToHash(args));
                const checkResultHash = crypto_1.createHash('sha1')
                    .update(JSON.stringify(checkResult))
                    .digest('base64');
                const lastResultHash = this.shouldRunCheckCache.get(cacheKey);
                this.shouldRunCheckCache.set(cacheKey, checkResultHash);
                if (checkResultHash === lastResultHash) {
                    return false;
                }
            }
        }
        return true;
    }
}
exports.ShippingEligibilityChecker = ShippingEligibilityChecker;
//# sourceMappingURL=shipping-eligibility-checker.js.map