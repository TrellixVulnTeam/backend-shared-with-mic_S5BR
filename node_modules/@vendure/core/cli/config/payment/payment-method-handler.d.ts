import { ConfigArg, RefundOrderInput } from '@vendure/common/lib/generated-types';
import { RequestContext } from '../../api/common/request-context';
import { ConfigArgs, ConfigArgValues, ConfigurableOperationDef, ConfigurableOperationDefOptions } from '../../common/configurable-operation';
import { OnTransitionStartFn, StateMachineConfig } from '../../common/finite-state-machine/types';
import { PaymentMetadata } from '../../common/types/common-types';
import { Order } from '../../entity/order/order.entity';
import { Payment } from '../../entity/payment/payment.entity';
import { PaymentState, PaymentTransitionData } from '../../service/helpers/payment-state-machine/payment-state';
import { RefundState } from '../../service/helpers/refund-state-machine/refund-state';
export declare type OnPaymentTransitionStartReturnType = ReturnType<Required<StateMachineConfig<any>>['onTransitionStart']>;
export interface CreatePaymentResult {
    amount: number;
    state: Exclude<PaymentState, 'Error'>;
    transactionId?: string;
    errorMessage?: string;
    metadata?: PaymentMetadata;
}
export interface CreatePaymentErrorResult {
    amount: number;
    state: 'Error';
    transactionId?: string;
    errorMessage: string;
    metadata?: PaymentMetadata;
}
export interface CreateRefundResult {
    state: RefundState;
    transactionId?: string;
    metadata?: PaymentMetadata;
}
export interface SettlePaymentResult {
    success: true;
    metadata?: PaymentMetadata;
}
export interface SettlePaymentErrorResult {
    success: false;
    state?: Exclude<PaymentState, 'Settled'>;
    errorMessage?: string;
    metadata?: PaymentMetadata;
}
export declare type CreatePaymentFn<T extends ConfigArgs> = (ctx: RequestContext, order: Order, amount: number, args: ConfigArgValues<T>, metadata: PaymentMetadata) => CreatePaymentResult | CreatePaymentErrorResult | Promise<CreatePaymentResult | CreatePaymentErrorResult>;
export declare type SettlePaymentFn<T extends ConfigArgs> = (ctx: RequestContext, order: Order, payment: Payment, args: ConfigArgValues<T>) => SettlePaymentResult | SettlePaymentErrorResult | Promise<SettlePaymentResult | SettlePaymentErrorResult>;
export declare type CreateRefundFn<T extends ConfigArgs> = (ctx: RequestContext, input: RefundOrderInput, amount: number, order: Order, payment: Payment, args: ConfigArgValues<T>) => CreateRefundResult | Promise<CreateRefundResult>;
export interface PaymentMethodConfigOptions<T extends ConfigArgs> extends ConfigurableOperationDefOptions<T> {
    createPayment: CreatePaymentFn<T>;
    settlePayment: SettlePaymentFn<T>;
    createRefund?: CreateRefundFn<T>;
    onStateTransitionStart?: OnTransitionStartFn<PaymentState, PaymentTransitionData>;
}
export declare class PaymentMethodHandler<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {
    private readonly createPaymentFn;
    private readonly settlePaymentFn;
    private readonly createRefundFn?;
    private readonly onTransitionStartFn?;
    constructor(config: PaymentMethodConfigOptions<T>);
    createPayment(ctx: RequestContext, order: Order, amount: number, args: ConfigArg[], metadata: PaymentMetadata): Promise<{
        amount: number;
        state: "Created" | "Cancelled" | "Authorized" | "Settled" | "Declined";
        transactionId?: string | undefined;
        errorMessage?: string | undefined;
        metadata: {};
        method: string;
    } | {
        amount: number;
        state: "Error";
        transactionId?: string | undefined;
        errorMessage: string;
        metadata: {};
        method: string;
    }>;
    settlePayment(ctx: RequestContext, order: Order, payment: Payment, args: ConfigArg[]): Promise<SettlePaymentResult | SettlePaymentErrorResult>;
    createRefund(ctx: RequestContext, input: RefundOrderInput, amount: number, order: Order, payment: Payment, args: ConfigArg[]): Promise<false | CreateRefundResult>;
    onStateTransitionStart(fromState: PaymentState, toState: PaymentState, data: PaymentTransitionData): OnPaymentTransitionStartReturnType;
}
