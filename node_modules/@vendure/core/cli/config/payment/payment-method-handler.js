"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentMethodHandler = void 0;
const configurable_operation_1 = require("../../common/configurable-operation");
class PaymentMethodHandler extends configurable_operation_1.ConfigurableOperationDef {
    constructor(config) {
        super(config);
        this.createPaymentFn = config.createPayment;
        this.settlePaymentFn = config.settlePayment;
        this.settlePaymentFn = config.settlePayment;
        this.createRefundFn = config.createRefund;
        this.onTransitionStartFn = config.onStateTransitionStart;
    }
    async createPayment(ctx, order, amount, args, metadata) {
        const paymentConfig = await this.createPaymentFn(ctx, order, amount, this.argsArrayToHash(args), metadata);
        return Object.assign({ method: this.code, metadata: {} }, paymentConfig);
    }
    async settlePayment(ctx, order, payment, args) {
        return this.settlePaymentFn(ctx, order, payment, this.argsArrayToHash(args));
    }
    async createRefund(ctx, input, amount, order, payment, args) {
        return this.createRefundFn
            ? this.createRefundFn(ctx, input, amount, order, payment, this.argsArrayToHash(args))
            : false;
    }
    onStateTransitionStart(fromState, toState, data) {
        if (typeof this.onTransitionStartFn === 'function') {
            return this.onTransitionStartFn(fromState, toState, data);
        }
        else {
            return true;
        }
    }
}
exports.PaymentMethodHandler = PaymentMethodHandler;
//# sourceMappingURL=payment-method-handler.js.map