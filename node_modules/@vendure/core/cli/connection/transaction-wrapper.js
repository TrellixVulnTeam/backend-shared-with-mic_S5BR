"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionWrapper = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const TransactionAlreadyStartedError_1 = require("typeorm/error/TransactionAlreadyStartedError");
const constants_1 = require("../common/constants");
class TransactionWrapper {
    async executeInTransaction(ctx, work, mode, connection) {
        const queryRunnerExists = !!ctx[constants_1.TRANSACTION_MANAGER_KEY];
        if (queryRunnerExists) {
            return rxjs_1.from(work()).toPromise();
        }
        const queryRunner = connection.createQueryRunner();
        if (mode === 'auto') {
            await this.startTransaction(queryRunner);
        }
        ctx[constants_1.TRANSACTION_MANAGER_KEY] = queryRunner.manager;
        try {
            const maxRetries = 5;
            const result = await rxjs_1.from(work())
                .pipe(operators_1.retryWhen(errors => errors.pipe(operators_1.tap(err => {
                if (!this.isRetriableError(err)) {
                    throw err;
                }
            }), operators_1.take(maxRetries))))
                .toPromise();
            if (queryRunner.isTransactionActive) {
                await queryRunner.commitTransaction();
            }
            return result;
        }
        catch (error) {
            if (queryRunner.isTransactionActive) {
                await queryRunner.rollbackTransaction();
            }
            throw error;
        }
        finally {
            if ((queryRunner === null || queryRunner === void 0 ? void 0 : queryRunner.isReleased) === false) {
                await queryRunner.release();
            }
        }
    }
    async startTransaction(queryRunner) {
        const maxRetries = 25;
        let attempts = 0;
        let lastError;
        async function attemptStartTransaction() {
            try {
                await queryRunner.startTransaction();
                return true;
            }
            catch (err) {
                lastError = err;
                if (err instanceof TransactionAlreadyStartedError_1.TransactionAlreadyStartedError) {
                    return false;
                }
                throw err;
            }
        }
        while (attempts < maxRetries) {
            const result = await attemptStartTransaction();
            if (result) {
                return;
            }
            attempts++;
            await new Promise(resolve => setTimeout(resolve, attempts * 20));
        }
        throw lastError;
    }
    isRetriableError(err) {
        const mysqlDeadlock = err.code === 'ER_LOCK_DEADLOCK';
        const postgresDeadlock = err.code === 'deadlock_detected';
        return mysqlDeadlock || postgresDeadlock;
    }
}
exports.TransactionWrapper = TransactionWrapper;
//# sourceMappingURL=transaction-wrapper.js.map