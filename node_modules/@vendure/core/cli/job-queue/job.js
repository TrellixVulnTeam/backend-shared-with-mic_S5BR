"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Job = void 0;
const generated_types_1 = require("@vendure/common/lib/generated-types");
const shared_utils_1 = require("@vendure/common/lib/shared-utils");
const vendure_logger_1 = require("../config/logger/vendure-logger");
class Job {
    constructor(config) {
        this.eventListeners = {
            progress: [],
        };
        this.queueName = config.queueName;
        this._data = this.ensureDataIsSerializable(config.data);
        this.id = config.id || null;
        this._state = config.state || generated_types_1.JobState.PENDING;
        this.retries = config.retries || 0;
        this._attempts = config.attempts || 0;
        this._progress = config.progress || 0;
        this.createdAt = config.createdAt || new Date();
        this._result = config.result;
        this._error = config.error;
        this._startedAt = config.startedAt;
        this._settledAt = config.settledAt;
    }
    get name() {
        return this.queueName;
    }
    get data() {
        return this._data;
    }
    get state() {
        return this._state;
    }
    get progress() {
        return this._progress;
    }
    get result() {
        return this._result;
    }
    get error() {
        return this._error;
    }
    get isSettled() {
        return (!!this._settledAt &&
            (this._state === generated_types_1.JobState.COMPLETED ||
                this._state === generated_types_1.JobState.FAILED ||
                this._state === generated_types_1.JobState.CANCELLED));
    }
    get startedAt() {
        return this._startedAt;
    }
    get settledAt() {
        return this._settledAt;
    }
    get duration() {
        if (this.state === generated_types_1.JobState.PENDING || this.state === generated_types_1.JobState.RETRYING) {
            return 0;
        }
        const end = this._settledAt || new Date();
        return +end - +(this._startedAt || end);
    }
    get attempts() {
        return this._attempts;
    }
    start() {
        if (this._state === generated_types_1.JobState.PENDING || this._state === generated_types_1.JobState.RETRYING) {
            this._state = generated_types_1.JobState.RUNNING;
            this._startedAt = new Date();
            this._attempts++;
            vendure_logger_1.Logger.debug(`Job ${this.id} [${this.queueName}] starting (attempt ${this._attempts} of ${this.retries + 1})`);
        }
    }
    setProgress(percent) {
        this._progress = Math.min(percent || 0, 100);
        this.fireEvent('progress');
    }
    complete(result) {
        this._result = result;
        this._progress = 100;
        this._state = generated_types_1.JobState.COMPLETED;
        this._settledAt = new Date();
        vendure_logger_1.Logger.debug(`Job ${this.id} [${this.queueName}] completed`);
    }
    fail(err) {
        this._error = (err === null || err === void 0 ? void 0 : err.message) ? err.message : String(err);
        this._progress = 0;
        if (this.retries >= this._attempts) {
            this._state = generated_types_1.JobState.RETRYING;
            vendure_logger_1.Logger.warn(`Job ${this.id} [${this.queueName}] failed (attempt ${this._attempts} of ${this.retries + 1})`);
        }
        else {
            if (this._state !== generated_types_1.JobState.CANCELLED) {
                this._state = generated_types_1.JobState.FAILED;
                vendure_logger_1.Logger.warn(`Job ${this.id} [${this.queueName}] failed and will not retry.`);
            }
            this._settledAt = new Date();
        }
    }
    cancel() {
        this._settledAt = new Date();
        this._state = generated_types_1.JobState.CANCELLED;
    }
    defer() {
        if (this._state === generated_types_1.JobState.RUNNING) {
            this._state = generated_types_1.JobState.PENDING;
            this._attempts = 0;
            vendure_logger_1.Logger.debug(`Job ${this.id} [${this.queueName}] deferred back to PENDING state`);
        }
    }
    on(eventType, listener) {
        this.eventListeners[eventType].push(listener);
    }
    off(eventType, listener) {
        const idx = this.eventListeners[eventType].indexOf(listener);
        if (idx !== -1) {
            this.eventListeners[eventType].splice(idx, 1);
        }
    }
    fireEvent(eventType) {
        for (const listener of this.eventListeners[eventType]) {
            listener(this);
        }
    }
    ensureDataIsSerializable(data, output) {
        if (data instanceof Date) {
            return data.toISOString();
        }
        else if (shared_utils_1.isObject(data)) {
            if (!output) {
                output = {};
            }
            for (const key of Object.keys(data)) {
                output[key] = this.ensureDataIsSerializable(data[key]);
            }
            if (shared_utils_1.isClassInstance(data)) {
                const descriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(data));
                for (const name of Object.keys(descriptors)) {
                    const descriptor = descriptors[name];
                    if (typeof descriptor.get === 'function') {
                        output[name] = data[name];
                    }
                }
            }
        }
        else if (Array.isArray(data)) {
            if (!output) {
                output = [];
            }
            data.forEach((item, i) => {
                output[i] = this.ensureDataIsSerializable(item);
            });
        }
        else {
            return data;
        }
        return output;
    }
}
exports.Job = Job;
//# sourceMappingURL=job.js.map