"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestContext = void 0;
const shared_utils_1 = require("@vendure/common/lib/shared-utils");
const utils_1 = require("../../common/utils");
const channel_entity_1 = require("../../entity/channel/channel.entity");
class RequestContext {
    constructor(options) {
        const { req, apiType, channel, session, languageCode, translationFn } = options;
        this._req = req;
        this._apiType = apiType;
        this._channel = channel;
        this._session = session;
        this._languageCode = languageCode || (channel && channel.defaultLanguageCode);
        this._isAuthorized = options.isAuthorized;
        this._authorizedAsOwnerOnly = options.authorizedAsOwnerOnly;
        this._translationFn = translationFn || ((key) => key);
    }
    static empty() {
        return new RequestContext({
            apiType: 'admin',
            authorizedAsOwnerOnly: false,
            channel: new channel_entity_1.Channel(),
            isAuthorized: true,
        });
    }
    static deserialize(ctxObject) {
        var _a;
        return new RequestContext({
            req: ctxObject._req,
            apiType: ctxObject._apiType,
            channel: new channel_entity_1.Channel(ctxObject._channel),
            session: Object.assign(Object.assign({}, ctxObject._session), { expires: ((_a = ctxObject._session) === null || _a === void 0 ? void 0 : _a.expires) && new Date(ctxObject._session.expires) }),
            languageCode: ctxObject._languageCode,
            isAuthorized: ctxObject._isAuthorized,
            authorizedAsOwnerOnly: ctxObject._authorizedAsOwnerOnly,
        });
    }
    userHasPermissions(permissions) {
        var _a;
        const user = (_a = this.session) === null || _a === void 0 ? void 0 : _a.user;
        if (!user || !this.channelId) {
            return false;
        }
        const permissionsOnChannel = user.channelPermissions.find(c => utils_1.idsAreEqual(c.id, this.channelId));
        if (permissionsOnChannel) {
            return this.arraysIntersect(permissionsOnChannel.permissions, permissions);
        }
        return false;
    }
    serialize() {
        const serializableThis = Object.assign({}, this);
        if (this._req) {
            serializableThis._req = this.shallowCloneRequestObject(this._req);
        }
        return JSON.parse(JSON.stringify(serializableThis));
    }
    copy() {
        return Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    }
    get req() {
        return this._req;
    }
    get apiType() {
        return this._apiType;
    }
    get channel() {
        return this._channel;
    }
    get channelId() {
        return this._channel.id;
    }
    get languageCode() {
        return this._languageCode;
    }
    get session() {
        return this._session;
    }
    get activeUserId() {
        var _a, _b;
        return (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.id;
    }
    get isAuthorized() {
        return this._isAuthorized;
    }
    get authorizedAsOwnerOnly() {
        return this._authorizedAsOwnerOnly;
    }
    translate(key, variables) {
        try {
            return this._translationFn(key, variables);
        }
        catch (e) {
            return `Translation format error: ${e.message}). Original key: ${key}`;
        }
    }
    arraysIntersect(arr1, arr2) {
        return arr1.reduce((intersects, role) => {
            return intersects || arr2.includes(role);
        }, false);
    }
    shallowCloneRequestObject(req) {
        function copySimpleFieldsToDepth(target, maxDepth, depth = 0) {
            const result = {};
            for (const key in target) {
                if (key === 'host' && depth === 0) {
                    continue;
                }
                let val;
                try {
                    val = target[key];
                }
                catch (e) {
                    val = String(e);
                }
                if (Array.isArray(val)) {
                    depth++;
                    result[key] = val.map(v => {
                        if (!shared_utils_1.isObject(v) && typeof val !== 'function') {
                            return v;
                        }
                        else {
                            return copySimpleFieldsToDepth(v, maxDepth, depth);
                        }
                    });
                    depth--;
                }
                else if (!shared_utils_1.isObject(val) && typeof val !== 'function') {
                    result[key] = val;
                }
                else if (depth < maxDepth) {
                    depth++;
                    result[key] = copySimpleFieldsToDepth(val, maxDepth, depth);
                    depth--;
                }
            }
            return result;
        }
        return copySimpleFieldsToDepth(req, 1);
    }
}
exports.RequestContext = RequestContext;
//# sourceMappingURL=request-context.js.map