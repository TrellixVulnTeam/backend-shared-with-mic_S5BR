"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdCodec = void 0;
const ID_KEYS = ['id'];
class IdCodec {
    constructor(entityIdStrategy) {
        this.entityIdStrategy = entityIdStrategy;
    }
    decode(target, transformKeys) {
        const transformKeysWithId = [...(transformKeys || []), ...ID_KEYS];
        return this.transformRecursive(target, input => this.entityIdStrategy.decodeId(input), transformKeysWithId);
    }
    encode(target, transformKeys) {
        const transformKeysWithId = [...(transformKeys || []), ...ID_KEYS];
        return this.transformRecursive(target, input => this.entityIdStrategy.encodeId(input), transformKeysWithId);
    }
    transformRecursive(target, transformFn, transformKeys) {
        if (target == null ||
            typeof target === 'boolean' ||
            target instanceof Promise ||
            target instanceof Date ||
            target instanceof RegExp) {
            return target;
        }
        if (typeof target === 'string' || typeof target === 'number') {
            return transformFn(target);
        }
        if (Array.isArray(target)) {
            target = target.slice(0);
            if (target.length === 0 || typeof target[0] === 'string' || typeof target[0] === 'number') {
                return target;
            }
            const isSimpleObject = this.isSimpleObject(target[0]);
            if (isSimpleObject) {
                const length = target.length;
                for (let i = 0; i < length; i++) {
                    target[i] = this.transform(target[i], transformFn, transformKeys);
                }
            }
            else {
                const length = target.length;
                for (let i = 0; i < length; i++) {
                    target[i] = this.transformRecursive(target[i], transformFn, transformKeys);
                }
            }
        }
        else {
            target = this.transform(target, transformFn, transformKeys);
            for (const key of Object.keys(target)) {
                if (this.isObject(target[key])) {
                    target[key] = this.transformRecursive(target[key], transformFn, transformKeys);
                }
            }
        }
        return target;
    }
    transform(target, transformFn, transformKeys) {
        if (target == null) {
            return target;
        }
        const clone = Object.assign({}, target);
        if (transformKeys) {
            for (const key of transformKeys) {
                if (target[key]) {
                    const val = target[key];
                    if (Array.isArray(val)) {
                        clone[key] = val.map(v => transformFn(v));
                    }
                    else {
                        clone[key] = transformFn(val);
                    }
                }
            }
        }
        return clone;
    }
    isSimpleObject(target) {
        if (!target) {
            return true;
        }
        const values = Object.values(target);
        for (const value of values) {
            if (this.isObject(value) || value === null) {
                return false;
            }
        }
        return true;
    }
    isObject(target) {
        return typeof target === 'object' && target != null;
    }
}
exports.IdCodec = IdCodec;
//# sourceMappingURL=id-codec.js.map