"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurableOperationDef = void 0;
const shared_utils_1 = require("@vendure/common/lib/shared-utils");
const constants_1 = require("./constants");
const errors_1 = require("./error/errors");
class ConfigurableOperationDef {
    constructor(options) {
        this.options = options;
    }
    get code() {
        return this.options.code;
    }
    get args() {
        return this.options.args;
    }
    get description() {
        return this.options.description;
    }
    async init(injector) {
        if (typeof this.options.init === 'function') {
            await this.options.init(injector);
        }
    }
    async destroy() {
        if (typeof this.options.destroy === 'function') {
            await this.options.destroy();
        }
    }
    toGraphQlType(ctx) {
        return {
            code: this.code,
            description: localizeString(this.description, ctx.languageCode),
            args: Object.entries(this.args).map(([name, arg]) => {
                var _a, _b;
                return ({
                    name,
                    type: arg.type,
                    list: (_a = arg.list) !== null && _a !== void 0 ? _a : false,
                    required: (_b = arg.required) !== null && _b !== void 0 ? _b : true,
                    defaultValue: arg.defaultValue,
                    ui: arg.ui,
                    label: arg.label && localizeString(arg.label, ctx.languageCode),
                    description: arg.description && localizeString(arg.description, ctx.languageCode),
                });
            }),
        };
    }
    argsArrayToHash(args) {
        const output = {};
        for (const arg of args) {
            if (arg && arg.value != null && this.args[arg.name] != null) {
                output[arg.name] = coerceValueToType(arg.value, this.args[arg.name].type, this.args[arg.name].list || false);
            }
        }
        return output;
    }
}
exports.ConfigurableOperationDef = ConfigurableOperationDef;
function localizeString(stringArray, languageCode) {
    let match = stringArray.find(x => x.languageCode === languageCode);
    if (!match) {
        match = stringArray.find(x => x.languageCode === constants_1.DEFAULT_LANGUAGE_CODE);
    }
    if (!match) {
        match = stringArray[0];
    }
    return match.value;
}
function coerceValueToType(value, type, isList) {
    if (isList) {
        try {
            return JSON.parse(value).map(v => coerceValueToType(v, type, false));
        }
        catch (err) {
            throw new errors_1.InternalServerError(err.message);
        }
    }
    switch (type) {
        case 'string':
            return value;
        case 'int':
            return Number.parseInt(value || '', 10);
        case 'float':
            return Number.parseFloat(value || '');
        case 'datetime':
            return Date.parse(value || '');
        case 'boolean':
            return !!(value && (value.toLowerCase() === 'true' || value === '1'));
        case 'ID':
            return value;
        default:
            shared_utils_1.assertNever(type);
    }
}
//# sourceMappingURL=configurable-operation.js.map