import { ConfigArg, ConfigurableOperationDefinition, LocalizedString, Maybe, StringFieldOption } from '@vendure/common/lib/generated-types';
import { ConfigArgType, ID, UiComponentConfig } from '@vendure/common/lib/shared-types';
import { RequestContext } from '../api/common/request-context';
import { Injector } from './injector';
import { InjectableStrategy } from './types/injectable-strategy';
export declare type LocalizedStringArray = Array<Omit<LocalizedString, '__typename'>>;
export interface ConfigArgCommonDef<T extends ConfigArgType> {
    type: T;
    required?: boolean;
    defaultValue?: ConfigArgTypeToTsType<T>;
    list?: boolean;
    label?: LocalizedStringArray;
    description?: LocalizedStringArray;
    ui?: UiComponentConfig<string>;
}
export declare type ConfigArgListDef<T extends ConfigArgType, C extends ConfigArgCommonDef<T> = ConfigArgCommonDef<T>> = C & {
    list: true;
};
export declare type WithArgConfig<T> = {
    config?: T;
};
export declare type StringArgConfig = WithArgConfig<{
    options?: Maybe<StringFieldOption[]>;
}>;
export declare type IntArgConfig = WithArgConfig<{
    inputType?: 'default' | 'percentage' | 'money';
}>;
export declare type ConfigArgDef<T extends ConfigArgType> = T extends 'string' ? ConfigArgCommonDef<'string'> & StringArgConfig : T extends 'int' ? ConfigArgCommonDef<'int'> & IntArgConfig : ConfigArgCommonDef<T> & WithArgConfig<never>;
export declare type ConfigArgs = {
    [name: string]: ConfigArgDef<ConfigArgType>;
};
export declare type ConfigArgValues<T extends ConfigArgs> = {
    [K in keyof T]: ConfigArgDefToType<T[K]>;
};
export declare type ConfigArgDefToType<D extends ConfigArgDef<ConfigArgType>> = D extends ConfigArgListDef<'int' | 'float'> ? number[] : D extends ConfigArgDef<'int' | 'float'> ? number : D extends ConfigArgListDef<'datetime'> ? Date[] : D extends ConfigArgDef<'datetime'> ? Date : D extends ConfigArgListDef<'boolean'> ? boolean[] : D extends ConfigArgDef<'boolean'> ? boolean : D extends ConfigArgListDef<'ID'> ? ID[] : D extends ConfigArgDef<'ID'> ? ID : D extends ConfigArgListDef<'string'> ? string[] : string;
export declare type ConfigArgTypeToTsType<T extends ConfigArgType> = T extends 'string' ? string : T extends 'int' ? number : T extends 'float' ? number : T extends 'boolean' ? boolean : T extends 'datetime' ? Date : ID;
export declare type TypeToConfigArgDef<T extends ConfigArgDefToType<any>> = T extends number ? ConfigArgDef<'int' | 'float'> : T extends number[] ? ConfigArgListDef<'int' | 'float'> : T extends Date[] ? ConfigArgListDef<'datetime'> : T extends Date ? ConfigArgDef<'datetime'> : T extends boolean[] ? ConfigArgListDef<'boolean'> : T extends boolean ? ConfigArgDef<'boolean'> : T extends string[] ? ConfigArgListDef<'string'> : T extends string ? ConfigArgDef<'string'> : T extends ID[] ? ConfigArgListDef<'ID'> : ConfigArgDef<'ID'>;
export interface ConfigurableOperationDefOptions<T extends ConfigArgs> extends InjectableStrategy {
    code: string;
    args: T;
    description: LocalizedStringArray;
}
export declare class ConfigurableOperationDef<T extends ConfigArgs = ConfigArgs> {
    protected options: ConfigurableOperationDefOptions<T>;
    get code(): string;
    get args(): T;
    get description(): LocalizedStringArray;
    constructor(options: ConfigurableOperationDefOptions<T>);
    init(injector: Injector): Promise<void>;
    destroy(): Promise<void>;
    toGraphQlType(ctx: RequestContext): ConfigurableOperationDefinition;
    protected argsArrayToHash(args: ConfigArg[]): ConfigArgValues<T>;
}
