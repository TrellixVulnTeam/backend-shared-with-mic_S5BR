"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FSM = void 0;
const utils_1 = require("../utils");
class FSM {
    constructor(config, initialState) {
        this.config = config;
        this._currentState = initialState;
        this._initialState = initialState;
    }
    get initialState() {
        return this._initialState;
    }
    get currentState() {
        return this._currentState;
    }
    async transitionTo(state, data) {
        if (this.canTransitionTo(state)) {
            if (typeof this.config.onTransitionStart === 'function') {
                const canTransition = await utils_1.awaitPromiseOrObservable(this.config.onTransitionStart(this._currentState, state, data));
                if (canTransition === false) {
                    return;
                }
                else if (typeof canTransition === 'string') {
                    await this.onError(this._currentState, state, canTransition);
                    return;
                }
            }
            const fromState = this._currentState;
            this._currentState = state;
            if (typeof this.config.onTransitionEnd === 'function') {
                await utils_1.awaitPromiseOrObservable(this.config.onTransitionEnd(fromState, state, data));
            }
        }
        else {
            return this.onError(this._currentState, state);
        }
    }
    jumpTo(state) {
        this._currentState = state;
    }
    getNextStates() {
        return this.config.transitions[this._currentState].to;
    }
    canTransitionTo(state) {
        return -1 < this.config.transitions[this._currentState].to.indexOf(state);
    }
    async onError(fromState, toState, message) {
        if (typeof this.config.onError === 'function') {
            await utils_1.awaitPromiseOrObservable(this.config.onError(fromState, toState, message));
        }
    }
}
exports.FSM = FSM;
//# sourceMappingURL=finite-state-machine.js.map