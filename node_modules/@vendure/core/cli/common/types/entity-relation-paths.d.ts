import { VendureEntity } from '../../entity/base/base.entity';
export declare type EntityRelationPaths<T extends VendureEntity> = `customFields.${string}` | PathsToStringProps1<T> | Join<PathsToStringProps2<T>, '.'> | TripleDotPath;
export declare type EntityRelationKeys<T extends VendureEntity> = {
    [K in Extract<keyof T, string>]: Required<T>[K] extends VendureEntity | null ? K : Required<T>[K] extends VendureEntity[] ? K : never;
}[Extract<keyof T, string>];
export declare type EntityRelations<T extends VendureEntity> = {
    [K in EntityRelationKeys<T>]: T[K];
};
export declare type PathsToStringProps1<T extends VendureEntity> = T extends string ? [] : {
    [K in EntityRelationKeys<T>]: K;
}[Extract<EntityRelationKeys<T>, string>];
export declare type PathsToStringProps2<T extends VendureEntity> = T extends string ? never : {
    [K in EntityRelationKeys<T>]: T[K] extends VendureEntity[] ? [K, PathsToStringProps1<T[K][number]>] : T[K] extends VendureEntity ? [K, PathsToStringProps1<T[K]>] : never;
}[Extract<EntityRelationKeys<T>, string>];
export declare type TripleDotPath = `${string}.${string}.${string}`;
export declare type Join<T extends Array<string | any>, D extends string> = T extends [] ? never : T extends [infer F] ? F : T extends [infer F, ...infer R] ? F extends string ? `${F}${D}${Join<Extract<R, string[]>, D>}` : never : string;
