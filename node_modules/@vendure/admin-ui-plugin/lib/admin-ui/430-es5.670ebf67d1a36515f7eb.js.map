{"version":3,"mappings":"wIA0DYA,+EAAc,KACtBC,sBACAD,4DACAA,gBAuCJ,SAAYA,GACRA,gBACAA,gBACAA,kBAHJ,CAAYE,YAAS,KA0RrB,SAAYF,GAERA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YA1TJ,CAAYE,YAAY,KAydxB,SAAYF,GAERA,oBAEAA,4BAJJ,CAAYE,YAAc,KAuB1B,SAAYF,GACRA,gCACAA,0DACAA,wDACAA,8DACAA,8DACAA,wCACAA,oDACAA,sDACAA,wDACAA,wDACAA,oDACAA,sDACAA,sEACAA,wDACAA,oEACAA,8CACAA,kDACAA,oDACAA,kDACAA,wDACAA,0DACAA,sEACAA,sEACAA,gFACAA,gFACAA,0EACAA,0EACAA,0CACAA,gDA7BJ,CAAYE,YAAS,KAwKrB,SAAYF,GACRA,cACAA,gBACAA,oBAHJ,CAAYE,YAAU,KA+CtB,SAAYF,GACRA,4CACAA,wCACAA,oDACAA,oDACAA,4DACAA,sDACAA,sDACAA,sDACAA,wDACAA,wEACAA,sEACAA,oEACAA,kEACAA,gCACAA,kDACAA,sDACAA,wCACAA,0CACAA,oDACAA,8DACAA,0BACAA,8CACAA,8CACAA,kCAxBJ,CAAYE,YAAgB,KAqH5B,SAAYF,GAERA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,oBAEAA,oBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UA1TJ,CAAYE,YAAY,KAkVxB,SAAYF,GACRA,YACAA,UAFJ,CAAYE,YAAe,KA+pB3B,SAAYF,GAERA,gCAEAA,0BAEAA,gBAEAA,kBAEAA,8CAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,kCAEAA,8BAEAA,kCAEAA,kCAEAA,4CAEAA,wCAEAA,4CAEAA,4CAEAA,4BAEAA,wBAEAA,4BAEAA,4BAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,sCAEAA,kCAEAA,sCAEAA,sCAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,kCAEAA,8BAEAA,kCAEAA,kCAEAA,4CAEAA,wCAEAA,4CAEAA,4CAEAA,4BAEAA,wBAEAA,4BAEAA,4BAEAA,4BAEAA,wBAEAA,4BAEAA,4BAEAA,4CAEAA,wCAEAA,4CAEAA,4CAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,oCAEAA,gCAEAA,oCAEAA,oCAEAA,8CAEAA,0CAEAA,8CAEAA,8CAEAA,wBAEAA,oBAEAA,wBAEAA,wBAEAA,wCAEAA,oCAEAA,wCAEAA,wCAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,8BAEAA,0BAEAA,8BAEAA,8BAEAA,0BAEAA,sBAEAA,0BAEAA,0BA1KJ,CAAYE,YAAU,KAosBtB,SAAYF,GACRA,YACAA,cAFJ,CAAYE,YAAS","names":["R","PROMOTION","E"],"sources":["webpack:///common/src/generated-shop-types.ts"],"sourcesContent":["// tslint:disable\r\nexport type Maybe<T> = T;\r\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\r\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\r\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\r\n/** All built-in and custom scalars, mapped to their actual values */\r\nexport type Scalars = {\r\n    ID: string | number;\r\n    String: string;\r\n    Boolean: boolean;\r\n    Int: number;\r\n    Float: number;\r\n    /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */\r\n    DateTime: any;\r\n    /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */\r\n    JSON: any;\r\n    /** The `Upload` scalar type represents a file upload. */\r\n    Upload: any;\r\n};\r\n\r\nexport type ActiveOrderResult = Order | NoActiveOrderError;\r\n\r\nexport type AddPaymentToOrderResult =\r\n    | Order\r\n    | OrderPaymentStateError\r\n    | IneligiblePaymentMethodError\r\n    | PaymentFailedError\r\n    | PaymentDeclinedError\r\n    | OrderStateTransitionError\r\n    | NoActiveOrderError;\r\n\r\nexport type Address = Node & {\r\n    __typename?: 'Address';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    fullName?: Maybe<Scalars['String']>;\r\n    company?: Maybe<Scalars['String']>;\r\n    streetLine1: Scalars['String'];\r\n    streetLine2?: Maybe<Scalars['String']>;\r\n    city?: Maybe<Scalars['String']>;\r\n    province?: Maybe<Scalars['String']>;\r\n    postalCode?: Maybe<Scalars['String']>;\r\n    country: Country;\r\n    phoneNumber?: Maybe<Scalars['String']>;\r\n    defaultShippingAddress?: Maybe<Scalars['Boolean']>;\r\n    defaultBillingAddress?: Maybe<Scalars['Boolean']>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type Adjustment = {\r\n    __typename?: 'Adjustment';\r\n    adjustmentSource: Scalars['String'];\r\n    type: AdjustmentType;\r\n    description: Scalars['String'];\r\n    amount: Scalars['Int'];\r\n};\r\n\r\nexport enum AdjustmentType {\r\n    PROMOTION = 'PROMOTION',\r\n    DISTRIBUTED_ORDER_PROMOTION = 'DISTRIBUTED_ORDER_PROMOTION',\r\n    OTHER = 'OTHER',\r\n}\r\n\r\n/** Returned when attempting to set the Customer for an Order when already logged in. */\r\nexport type AlreadyLoggedInError = ErrorResult & {\r\n    __typename?: 'AlreadyLoggedInError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\nexport type ApplyCouponCodeResult =\r\n    | Order\r\n    | CouponCodeExpiredError\r\n    | CouponCodeInvalidError\r\n    | CouponCodeLimitError;\r\n\r\nexport type Asset = Node & {\r\n    __typename?: 'Asset';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    name: Scalars['String'];\r\n    type: AssetType;\r\n    fileSize: Scalars['Int'];\r\n    mimeType: Scalars['String'];\r\n    width: Scalars['Int'];\r\n    height: Scalars['Int'];\r\n    source: Scalars['String'];\r\n    preview: Scalars['String'];\r\n    focalPoint?: Maybe<Coordinate>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type AssetList = PaginatedList & {\r\n    __typename?: 'AssetList';\r\n    items: Array<Asset>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport enum AssetType {\r\n    IMAGE = 'IMAGE',\r\n    VIDEO = 'VIDEO',\r\n    BINARY = 'BINARY',\r\n}\r\n\r\nexport type AuthenticationInput = {\r\n    native?: Maybe<NativeAuthInput>;\r\n};\r\n\r\nexport type AuthenticationMethod = Node & {\r\n    __typename?: 'AuthenticationMethod';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    strategy: Scalars['String'];\r\n};\r\n\r\nexport type AuthenticationResult = CurrentUser | InvalidCredentialsError | NotVerifiedError;\r\n\r\nexport type BooleanCustomFieldConfig = CustomField & {\r\n    __typename?: 'BooleanCustomFieldConfig';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\n/** Operators for filtering on a list of Boolean fields */\r\nexport type BooleanListOperators = {\r\n    inList: Scalars['Boolean'];\r\n};\r\n\r\n/** Operators for filtering on a Boolean field */\r\nexport type BooleanOperators = {\r\n    eq?: Maybe<Scalars['Boolean']>;\r\n};\r\n\r\nexport type Channel = Node & {\r\n    __typename?: 'Channel';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    code: Scalars['String'];\r\n    token: Scalars['String'];\r\n    defaultTaxZone?: Maybe<Zone>;\r\n    defaultShippingZone?: Maybe<Zone>;\r\n    defaultLanguageCode: LanguageCode;\r\n    currencyCode: CurrencyCode;\r\n    pricesIncludeTax: Scalars['Boolean'];\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type Collection = Node & {\r\n    __typename?: 'Collection';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode?: Maybe<LanguageCode>;\r\n    name: Scalars['String'];\r\n    slug: Scalars['String'];\r\n    breadcrumbs: Array<CollectionBreadcrumb>;\r\n    position: Scalars['Int'];\r\n    description: Scalars['String'];\r\n    featuredAsset?: Maybe<Asset>;\r\n    assets: Array<Asset>;\r\n    parent?: Maybe<Collection>;\r\n    children?: Maybe<Array<Collection>>;\r\n    filters: Array<ConfigurableOperation>;\r\n    translations: Array<CollectionTranslation>;\r\n    productVariants: ProductVariantList;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type CollectionProductVariantsArgs = {\r\n    options?: Maybe<ProductVariantListOptions>;\r\n};\r\n\r\nexport type CollectionBreadcrumb = {\r\n    __typename?: 'CollectionBreadcrumb';\r\n    id: Scalars['ID'];\r\n    name: Scalars['String'];\r\n    slug: Scalars['String'];\r\n};\r\n\r\nexport type CollectionFilterParameter = {\r\n    id?: Maybe<IdOperators>;\r\n    createdAt?: Maybe<DateOperators>;\r\n    updatedAt?: Maybe<DateOperators>;\r\n    languageCode?: Maybe<StringOperators>;\r\n    name?: Maybe<StringOperators>;\r\n    slug?: Maybe<StringOperators>;\r\n    position?: Maybe<NumberOperators>;\r\n    description?: Maybe<StringOperators>;\r\n};\r\n\r\nexport type CollectionList = PaginatedList & {\r\n    __typename?: 'CollectionList';\r\n    items: Array<Collection>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type CollectionListOptions = {\r\n    /** Skips the first n results, for use in pagination */\r\n    skip?: Maybe<Scalars['Int']>;\r\n    /** Takes n results, for use in pagination */\r\n    take?: Maybe<Scalars['Int']>;\r\n    /** Specifies which properties to sort the results by */\r\n    sort?: Maybe<CollectionSortParameter>;\r\n    /** Allows the results to be filtered */\r\n    filter?: Maybe<CollectionFilterParameter>;\r\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\r\n    filterOperator?: Maybe<LogicalOperator>;\r\n};\r\n\r\n/**\r\n * Which Collections are present in the products returned\r\n * by the search, and in what quantity.\r\n */\r\nexport type CollectionResult = {\r\n    __typename?: 'CollectionResult';\r\n    collection: Collection;\r\n    count: Scalars['Int'];\r\n};\r\n\r\nexport type CollectionSortParameter = {\r\n    id?: Maybe<SortOrder>;\r\n    createdAt?: Maybe<SortOrder>;\r\n    updatedAt?: Maybe<SortOrder>;\r\n    name?: Maybe<SortOrder>;\r\n    slug?: Maybe<SortOrder>;\r\n    position?: Maybe<SortOrder>;\r\n    description?: Maybe<SortOrder>;\r\n};\r\n\r\nexport type CollectionTranslation = {\r\n    __typename?: 'CollectionTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n    slug: Scalars['String'];\r\n    description: Scalars['String'];\r\n};\r\n\r\nexport type ConfigArg = {\r\n    __typename?: 'ConfigArg';\r\n    name: Scalars['String'];\r\n    value: Scalars['String'];\r\n};\r\n\r\nexport type ConfigArgDefinition = {\r\n    __typename?: 'ConfigArgDefinition';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    required: Scalars['Boolean'];\r\n    defaultValue?: Maybe<Scalars['JSON']>;\r\n    label?: Maybe<Scalars['String']>;\r\n    description?: Maybe<Scalars['String']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type ConfigArgInput = {\r\n    name: Scalars['String'];\r\n    /** A JSON stringified representation of the actual value */\r\n    value: Scalars['String'];\r\n};\r\n\r\nexport type ConfigurableOperation = {\r\n    __typename?: 'ConfigurableOperation';\r\n    code: Scalars['String'];\r\n    args: Array<ConfigArg>;\r\n};\r\n\r\nexport type ConfigurableOperationDefinition = {\r\n    __typename?: 'ConfigurableOperationDefinition';\r\n    code: Scalars['String'];\r\n    args: Array<ConfigArgDefinition>;\r\n    description: Scalars['String'];\r\n};\r\n\r\nexport type ConfigurableOperationInput = {\r\n    code: Scalars['String'];\r\n    arguments: Array<ConfigArgInput>;\r\n};\r\n\r\nexport type Coordinate = {\r\n    __typename?: 'Coordinate';\r\n    x: Scalars['Float'];\r\n    y: Scalars['Float'];\r\n};\r\n\r\nexport type Country = Node & {\r\n    __typename?: 'Country';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    code: Scalars['String'];\r\n    name: Scalars['String'];\r\n    enabled: Scalars['Boolean'];\r\n    translations: Array<CountryTranslation>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type CountryList = PaginatedList & {\r\n    __typename?: 'CountryList';\r\n    items: Array<Country>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type CountryTranslation = {\r\n    __typename?: 'CountryTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n};\r\n\r\n/** Returned if the provided coupon code is invalid */\r\nexport type CouponCodeExpiredError = ErrorResult & {\r\n    __typename?: 'CouponCodeExpiredError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    couponCode: Scalars['String'];\r\n};\r\n\r\n/** Returned if the provided coupon code is invalid */\r\nexport type CouponCodeInvalidError = ErrorResult & {\r\n    __typename?: 'CouponCodeInvalidError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    couponCode: Scalars['String'];\r\n};\r\n\r\n/** Returned if the provided coupon code is invalid */\r\nexport type CouponCodeLimitError = ErrorResult & {\r\n    __typename?: 'CouponCodeLimitError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    couponCode: Scalars['String'];\r\n    limit: Scalars['Int'];\r\n};\r\n\r\nexport type CreateAddressInput = {\r\n    fullName?: Maybe<Scalars['String']>;\r\n    company?: Maybe<Scalars['String']>;\r\n    streetLine1: Scalars['String'];\r\n    streetLine2?: Maybe<Scalars['String']>;\r\n    city?: Maybe<Scalars['String']>;\r\n    province?: Maybe<Scalars['String']>;\r\n    postalCode?: Maybe<Scalars['String']>;\r\n    countryCode: Scalars['String'];\r\n    phoneNumber?: Maybe<Scalars['String']>;\r\n    defaultShippingAddress?: Maybe<Scalars['Boolean']>;\r\n    defaultBillingAddress?: Maybe<Scalars['Boolean']>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type CreateCustomerInput = {\r\n    title?: Maybe<Scalars['String']>;\r\n    firstName: Scalars['String'];\r\n    lastName: Scalars['String'];\r\n    phoneNumber?: Maybe<Scalars['String']>;\r\n    emailAddress: Scalars['String'];\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\n/**\r\n * @description\r\n * ISO 4217 currency code\r\n *\r\n * @docsCategory common\r\n */\r\nexport enum CurrencyCode {\r\n    /** United Arab Emirates dirham */\r\n    AED = 'AED',\r\n    /** Afghan afghani */\r\n    AFN = 'AFN',\r\n    /** Albanian lek */\r\n    ALL = 'ALL',\r\n    /** Armenian dram */\r\n    AMD = 'AMD',\r\n    /** Netherlands Antillean guilder */\r\n    ANG = 'ANG',\r\n    /** Angolan kwanza */\r\n    AOA = 'AOA',\r\n    /** Argentine peso */\r\n    ARS = 'ARS',\r\n    /** Australian dollar */\r\n    AUD = 'AUD',\r\n    /** Aruban florin */\r\n    AWG = 'AWG',\r\n    /** Azerbaijani manat */\r\n    AZN = 'AZN',\r\n    /** Bosnia and Herzegovina convertible mark */\r\n    BAM = 'BAM',\r\n    /** Barbados dollar */\r\n    BBD = 'BBD',\r\n    /** Bangladeshi taka */\r\n    BDT = 'BDT',\r\n    /** Bulgarian lev */\r\n    BGN = 'BGN',\r\n    /** Bahraini dinar */\r\n    BHD = 'BHD',\r\n    /** Burundian franc */\r\n    BIF = 'BIF',\r\n    /** Bermudian dollar */\r\n    BMD = 'BMD',\r\n    /** Brunei dollar */\r\n    BND = 'BND',\r\n    /** Boliviano */\r\n    BOB = 'BOB',\r\n    /** Brazilian real */\r\n    BRL = 'BRL',\r\n    /** Bahamian dollar */\r\n    BSD = 'BSD',\r\n    /** Bhutanese ngultrum */\r\n    BTN = 'BTN',\r\n    /** Botswana pula */\r\n    BWP = 'BWP',\r\n    /** Belarusian ruble */\r\n    BYN = 'BYN',\r\n    /** Belize dollar */\r\n    BZD = 'BZD',\r\n    /** Canadian dollar */\r\n    CAD = 'CAD',\r\n    /** Congolese franc */\r\n    CDF = 'CDF',\r\n    /** Swiss franc */\r\n    CHF = 'CHF',\r\n    /** Chilean peso */\r\n    CLP = 'CLP',\r\n    /** Renminbi (Chinese) yuan */\r\n    CNY = 'CNY',\r\n    /** Colombian peso */\r\n    COP = 'COP',\r\n    /** Costa Rican colon */\r\n    CRC = 'CRC',\r\n    /** Cuban convertible peso */\r\n    CUC = 'CUC',\r\n    /** Cuban peso */\r\n    CUP = 'CUP',\r\n    /** Cape Verde escudo */\r\n    CVE = 'CVE',\r\n    /** Czech koruna */\r\n    CZK = 'CZK',\r\n    /** Djiboutian franc */\r\n    DJF = 'DJF',\r\n    /** Danish krone */\r\n    DKK = 'DKK',\r\n    /** Dominican peso */\r\n    DOP = 'DOP',\r\n    /** Algerian dinar */\r\n    DZD = 'DZD',\r\n    /** Egyptian pound */\r\n    EGP = 'EGP',\r\n    /** Eritrean nakfa */\r\n    ERN = 'ERN',\r\n    /** Ethiopian birr */\r\n    ETB = 'ETB',\r\n    /** Euro */\r\n    EUR = 'EUR',\r\n    /** Fiji dollar */\r\n    FJD = 'FJD',\r\n    /** Falkland Islands pound */\r\n    FKP = 'FKP',\r\n    /** Pound sterling */\r\n    GBP = 'GBP',\r\n    /** Georgian lari */\r\n    GEL = 'GEL',\r\n    /** Ghanaian cedi */\r\n    GHS = 'GHS',\r\n    /** Gibraltar pound */\r\n    GIP = 'GIP',\r\n    /** Gambian dalasi */\r\n    GMD = 'GMD',\r\n    /** Guinean franc */\r\n    GNF = 'GNF',\r\n    /** Guatemalan quetzal */\r\n    GTQ = 'GTQ',\r\n    /** Guyanese dollar */\r\n    GYD = 'GYD',\r\n    /** Hong Kong dollar */\r\n    HKD = 'HKD',\r\n    /** Honduran lempira */\r\n    HNL = 'HNL',\r\n    /** Croatian kuna */\r\n    HRK = 'HRK',\r\n    /** Haitian gourde */\r\n    HTG = 'HTG',\r\n    /** Hungarian forint */\r\n    HUF = 'HUF',\r\n    /** Indonesian rupiah */\r\n    IDR = 'IDR',\r\n    /** Israeli new shekel */\r\n    ILS = 'ILS',\r\n    /** Indian rupee */\r\n    INR = 'INR',\r\n    /** Iraqi dinar */\r\n    IQD = 'IQD',\r\n    /** Iranian rial */\r\n    IRR = 'IRR',\r\n    /** Icelandic króna */\r\n    ISK = 'ISK',\r\n    /** Jamaican dollar */\r\n    JMD = 'JMD',\r\n    /** Jordanian dinar */\r\n    JOD = 'JOD',\r\n    /** Japanese yen */\r\n    JPY = 'JPY',\r\n    /** Kenyan shilling */\r\n    KES = 'KES',\r\n    /** Kyrgyzstani som */\r\n    KGS = 'KGS',\r\n    /** Cambodian riel */\r\n    KHR = 'KHR',\r\n    /** Comoro franc */\r\n    KMF = 'KMF',\r\n    /** North Korean won */\r\n    KPW = 'KPW',\r\n    /** South Korean won */\r\n    KRW = 'KRW',\r\n    /** Kuwaiti dinar */\r\n    KWD = 'KWD',\r\n    /** Cayman Islands dollar */\r\n    KYD = 'KYD',\r\n    /** Kazakhstani tenge */\r\n    KZT = 'KZT',\r\n    /** Lao kip */\r\n    LAK = 'LAK',\r\n    /** Lebanese pound */\r\n    LBP = 'LBP',\r\n    /** Sri Lankan rupee */\r\n    LKR = 'LKR',\r\n    /** Liberian dollar */\r\n    LRD = 'LRD',\r\n    /** Lesotho loti */\r\n    LSL = 'LSL',\r\n    /** Libyan dinar */\r\n    LYD = 'LYD',\r\n    /** Moroccan dirham */\r\n    MAD = 'MAD',\r\n    /** Moldovan leu */\r\n    MDL = 'MDL',\r\n    /** Malagasy ariary */\r\n    MGA = 'MGA',\r\n    /** Macedonian denar */\r\n    MKD = 'MKD',\r\n    /** Myanmar kyat */\r\n    MMK = 'MMK',\r\n    /** Mongolian tögrög */\r\n    MNT = 'MNT',\r\n    /** Macanese pataca */\r\n    MOP = 'MOP',\r\n    /** Mauritanian ouguiya */\r\n    MRU = 'MRU',\r\n    /** Mauritian rupee */\r\n    MUR = 'MUR',\r\n    /** Maldivian rufiyaa */\r\n    MVR = 'MVR',\r\n    /** Malawian kwacha */\r\n    MWK = 'MWK',\r\n    /** Mexican peso */\r\n    MXN = 'MXN',\r\n    /** Malaysian ringgit */\r\n    MYR = 'MYR',\r\n    /** Mozambican metical */\r\n    MZN = 'MZN',\r\n    /** Namibian dollar */\r\n    NAD = 'NAD',\r\n    /** Nigerian naira */\r\n    NGN = 'NGN',\r\n    /** Nicaraguan córdoba */\r\n    NIO = 'NIO',\r\n    /** Norwegian krone */\r\n    NOK = 'NOK',\r\n    /** Nepalese rupee */\r\n    NPR = 'NPR',\r\n    /** New Zealand dollar */\r\n    NZD = 'NZD',\r\n    /** Omani rial */\r\n    OMR = 'OMR',\r\n    /** Panamanian balboa */\r\n    PAB = 'PAB',\r\n    /** Peruvian sol */\r\n    PEN = 'PEN',\r\n    /** Papua New Guinean kina */\r\n    PGK = 'PGK',\r\n    /** Philippine peso */\r\n    PHP = 'PHP',\r\n    /** Pakistani rupee */\r\n    PKR = 'PKR',\r\n    /** Polish złoty */\r\n    PLN = 'PLN',\r\n    /** Paraguayan guaraní */\r\n    PYG = 'PYG',\r\n    /** Qatari riyal */\r\n    QAR = 'QAR',\r\n    /** Romanian leu */\r\n    RON = 'RON',\r\n    /** Serbian dinar */\r\n    RSD = 'RSD',\r\n    /** Russian ruble */\r\n    RUB = 'RUB',\r\n    /** Rwandan franc */\r\n    RWF = 'RWF',\r\n    /** Saudi riyal */\r\n    SAR = 'SAR',\r\n    /** Solomon Islands dollar */\r\n    SBD = 'SBD',\r\n    /** Seychelles rupee */\r\n    SCR = 'SCR',\r\n    /** Sudanese pound */\r\n    SDG = 'SDG',\r\n    /** Swedish krona/kronor */\r\n    SEK = 'SEK',\r\n    /** Singapore dollar */\r\n    SGD = 'SGD',\r\n    /** Saint Helena pound */\r\n    SHP = 'SHP',\r\n    /** Sierra Leonean leone */\r\n    SLL = 'SLL',\r\n    /** Somali shilling */\r\n    SOS = 'SOS',\r\n    /** Surinamese dollar */\r\n    SRD = 'SRD',\r\n    /** South Sudanese pound */\r\n    SSP = 'SSP',\r\n    /** São Tomé and Príncipe dobra */\r\n    STN = 'STN',\r\n    /** Salvadoran colón */\r\n    SVC = 'SVC',\r\n    /** Syrian pound */\r\n    SYP = 'SYP',\r\n    /** Swazi lilangeni */\r\n    SZL = 'SZL',\r\n    /** Thai baht */\r\n    THB = 'THB',\r\n    /** Tajikistani somoni */\r\n    TJS = 'TJS',\r\n    /** Turkmenistan manat */\r\n    TMT = 'TMT',\r\n    /** Tunisian dinar */\r\n    TND = 'TND',\r\n    /** Tongan paʻanga */\r\n    TOP = 'TOP',\r\n    /** Turkish lira */\r\n    TRY = 'TRY',\r\n    /** Trinidad and Tobago dollar */\r\n    TTD = 'TTD',\r\n    /** New Taiwan dollar */\r\n    TWD = 'TWD',\r\n    /** Tanzanian shilling */\r\n    TZS = 'TZS',\r\n    /** Ukrainian hryvnia */\r\n    UAH = 'UAH',\r\n    /** Ugandan shilling */\r\n    UGX = 'UGX',\r\n    /** United States dollar */\r\n    USD = 'USD',\r\n    /** Uruguayan peso */\r\n    UYU = 'UYU',\r\n    /** Uzbekistan som */\r\n    UZS = 'UZS',\r\n    /** Venezuelan bolívar soberano */\r\n    VES = 'VES',\r\n    /** Vietnamese đồng */\r\n    VND = 'VND',\r\n    /** Vanuatu vatu */\r\n    VUV = 'VUV',\r\n    /** Samoan tala */\r\n    WST = 'WST',\r\n    /** CFA franc BEAC */\r\n    XAF = 'XAF',\r\n    /** East Caribbean dollar */\r\n    XCD = 'XCD',\r\n    /** CFA franc BCEAO */\r\n    XOF = 'XOF',\r\n    /** CFP franc (franc Pacifique) */\r\n    XPF = 'XPF',\r\n    /** Yemeni rial */\r\n    YER = 'YER',\r\n    /** South African rand */\r\n    ZAR = 'ZAR',\r\n    /** Zambian kwacha */\r\n    ZMW = 'ZMW',\r\n    /** Zimbabwean dollar */\r\n    ZWL = 'ZWL',\r\n}\r\n\r\nexport type CurrentUser = {\r\n    __typename?: 'CurrentUser';\r\n    id: Scalars['ID'];\r\n    identifier: Scalars['String'];\r\n    channels: Array<CurrentUserChannel>;\r\n};\r\n\r\nexport type CurrentUserChannel = {\r\n    __typename?: 'CurrentUserChannel';\r\n    id: Scalars['ID'];\r\n    token: Scalars['String'];\r\n    code: Scalars['String'];\r\n    permissions: Array<Permission>;\r\n};\r\n\r\nexport type CustomField = {\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type CustomFieldConfig =\r\n    | StringCustomFieldConfig\r\n    | LocaleStringCustomFieldConfig\r\n    | IntCustomFieldConfig\r\n    | FloatCustomFieldConfig\r\n    | BooleanCustomFieldConfig\r\n    | DateTimeCustomFieldConfig\r\n    | RelationCustomFieldConfig\r\n    | TextCustomFieldConfig;\r\n\r\nexport type Customer = Node & {\r\n    __typename?: 'Customer';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    title?: Maybe<Scalars['String']>;\r\n    firstName: Scalars['String'];\r\n    lastName: Scalars['String'];\r\n    phoneNumber?: Maybe<Scalars['String']>;\r\n    emailAddress: Scalars['String'];\r\n    addresses?: Maybe<Array<Address>>;\r\n    orders: OrderList;\r\n    user?: Maybe<User>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type CustomerOrdersArgs = {\r\n    options?: Maybe<OrderListOptions>;\r\n};\r\n\r\nexport type CustomerFilterParameter = {\r\n    id?: Maybe<IdOperators>;\r\n    createdAt?: Maybe<DateOperators>;\r\n    updatedAt?: Maybe<DateOperators>;\r\n    title?: Maybe<StringOperators>;\r\n    firstName?: Maybe<StringOperators>;\r\n    lastName?: Maybe<StringOperators>;\r\n    phoneNumber?: Maybe<StringOperators>;\r\n    emailAddress?: Maybe<StringOperators>;\r\n};\r\n\r\nexport type CustomerGroup = Node & {\r\n    __typename?: 'CustomerGroup';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    name: Scalars['String'];\r\n    customers: CustomerList;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type CustomerGroupCustomersArgs = {\r\n    options?: Maybe<CustomerListOptions>;\r\n};\r\n\r\nexport type CustomerList = PaginatedList & {\r\n    __typename?: 'CustomerList';\r\n    items: Array<Customer>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type CustomerListOptions = {\r\n    /** Skips the first n results, for use in pagination */\r\n    skip?: Maybe<Scalars['Int']>;\r\n    /** Takes n results, for use in pagination */\r\n    take?: Maybe<Scalars['Int']>;\r\n    /** Specifies which properties to sort the results by */\r\n    sort?: Maybe<CustomerSortParameter>;\r\n    /** Allows the results to be filtered */\r\n    filter?: Maybe<CustomerFilterParameter>;\r\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\r\n    filterOperator?: Maybe<LogicalOperator>;\r\n};\r\n\r\nexport type CustomerSortParameter = {\r\n    id?: Maybe<SortOrder>;\r\n    createdAt?: Maybe<SortOrder>;\r\n    updatedAt?: Maybe<SortOrder>;\r\n    title?: Maybe<SortOrder>;\r\n    firstName?: Maybe<SortOrder>;\r\n    lastName?: Maybe<SortOrder>;\r\n    phoneNumber?: Maybe<SortOrder>;\r\n    emailAddress?: Maybe<SortOrder>;\r\n};\r\n\r\n/** Operators for filtering on a list of Date fields */\r\nexport type DateListOperators = {\r\n    inList: Scalars['DateTime'];\r\n};\r\n\r\n/** Operators for filtering on a DateTime field */\r\nexport type DateOperators = {\r\n    eq?: Maybe<Scalars['DateTime']>;\r\n    before?: Maybe<Scalars['DateTime']>;\r\n    after?: Maybe<Scalars['DateTime']>;\r\n    between?: Maybe<DateRange>;\r\n};\r\n\r\nexport type DateRange = {\r\n    start: Scalars['DateTime'];\r\n    end: Scalars['DateTime'];\r\n};\r\n\r\n/**\r\n * Expects the same validation formats as the `<input type=\"datetime-local\">` HTML element.\r\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local#Additional_attributes\r\n */\r\nexport type DateTimeCustomFieldConfig = CustomField & {\r\n    __typename?: 'DateTimeCustomFieldConfig';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    min?: Maybe<Scalars['String']>;\r\n    max?: Maybe<Scalars['String']>;\r\n    step?: Maybe<Scalars['Int']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type DeletionResponse = {\r\n    __typename?: 'DeletionResponse';\r\n    result: DeletionResult;\r\n    message?: Maybe<Scalars['String']>;\r\n};\r\n\r\nexport enum DeletionResult {\r\n    /** The entity was successfully deleted */\r\n    DELETED = 'DELETED',\r\n    /** Deletion did not take place, reason given in message */\r\n    NOT_DELETED = 'NOT_DELETED',\r\n}\r\n\r\nexport type Discount = {\r\n    __typename?: 'Discount';\r\n    adjustmentSource: Scalars['String'];\r\n    type: AdjustmentType;\r\n    description: Scalars['String'];\r\n    amount: Scalars['Int'];\r\n    amountWithTax: Scalars['Int'];\r\n};\r\n\r\n/** Returned when attempting to create a Customer with an email address already registered to an existing User. */\r\nexport type EmailAddressConflictError = ErrorResult & {\r\n    __typename?: 'EmailAddressConflictError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\nexport enum ErrorCode {\r\n    UNKNOWN_ERROR = 'UNKNOWN_ERROR',\r\n    NATIVE_AUTH_STRATEGY_ERROR = 'NATIVE_AUTH_STRATEGY_ERROR',\r\n    INVALID_CREDENTIALS_ERROR = 'INVALID_CREDENTIALS_ERROR',\r\n    ORDER_STATE_TRANSITION_ERROR = 'ORDER_STATE_TRANSITION_ERROR',\r\n    EMAIL_ADDRESS_CONFLICT_ERROR = 'EMAIL_ADDRESS_CONFLICT_ERROR',\r\n    ORDER_LIMIT_ERROR = 'ORDER_LIMIT_ERROR',\r\n    NEGATIVE_QUANTITY_ERROR = 'NEGATIVE_QUANTITY_ERROR',\r\n    INSUFFICIENT_STOCK_ERROR = 'INSUFFICIENT_STOCK_ERROR',\r\n    COUPON_CODE_INVALID_ERROR = 'COUPON_CODE_INVALID_ERROR',\r\n    COUPON_CODE_EXPIRED_ERROR = 'COUPON_CODE_EXPIRED_ERROR',\r\n    COUPON_CODE_LIMIT_ERROR = 'COUPON_CODE_LIMIT_ERROR',\r\n    ORDER_MODIFICATION_ERROR = 'ORDER_MODIFICATION_ERROR',\r\n    INELIGIBLE_SHIPPING_METHOD_ERROR = 'INELIGIBLE_SHIPPING_METHOD_ERROR',\r\n    ORDER_PAYMENT_STATE_ERROR = 'ORDER_PAYMENT_STATE_ERROR',\r\n    INELIGIBLE_PAYMENT_METHOD_ERROR = 'INELIGIBLE_PAYMENT_METHOD_ERROR',\r\n    PAYMENT_FAILED_ERROR = 'PAYMENT_FAILED_ERROR',\r\n    PAYMENT_DECLINED_ERROR = 'PAYMENT_DECLINED_ERROR',\r\n    ALREADY_LOGGED_IN_ERROR = 'ALREADY_LOGGED_IN_ERROR',\r\n    MISSING_PASSWORD_ERROR = 'MISSING_PASSWORD_ERROR',\r\n    PASSWORD_VALIDATION_ERROR = 'PASSWORD_VALIDATION_ERROR',\r\n    PASSWORD_ALREADY_SET_ERROR = 'PASSWORD_ALREADY_SET_ERROR',\r\n    VERIFICATION_TOKEN_INVALID_ERROR = 'VERIFICATION_TOKEN_INVALID_ERROR',\r\n    VERIFICATION_TOKEN_EXPIRED_ERROR = 'VERIFICATION_TOKEN_EXPIRED_ERROR',\r\n    IDENTIFIER_CHANGE_TOKEN_INVALID_ERROR = 'IDENTIFIER_CHANGE_TOKEN_INVALID_ERROR',\r\n    IDENTIFIER_CHANGE_TOKEN_EXPIRED_ERROR = 'IDENTIFIER_CHANGE_TOKEN_EXPIRED_ERROR',\r\n    PASSWORD_RESET_TOKEN_INVALID_ERROR = 'PASSWORD_RESET_TOKEN_INVALID_ERROR',\r\n    PASSWORD_RESET_TOKEN_EXPIRED_ERROR = 'PASSWORD_RESET_TOKEN_EXPIRED_ERROR',\r\n    NOT_VERIFIED_ERROR = 'NOT_VERIFIED_ERROR',\r\n    NO_ACTIVE_ORDER_ERROR = 'NO_ACTIVE_ORDER_ERROR',\r\n}\r\n\r\nexport type ErrorResult = {\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\nexport type Facet = Node & {\r\n    __typename?: 'Facet';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n    code: Scalars['String'];\r\n    values: Array<FacetValue>;\r\n    translations: Array<FacetTranslation>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type FacetFilterParameter = {\r\n    id?: Maybe<IdOperators>;\r\n    createdAt?: Maybe<DateOperators>;\r\n    updatedAt?: Maybe<DateOperators>;\r\n    languageCode?: Maybe<StringOperators>;\r\n    name?: Maybe<StringOperators>;\r\n    code?: Maybe<StringOperators>;\r\n};\r\n\r\nexport type FacetList = PaginatedList & {\r\n    __typename?: 'FacetList';\r\n    items: Array<Facet>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type FacetListOptions = {\r\n    /** Skips the first n results, for use in pagination */\r\n    skip?: Maybe<Scalars['Int']>;\r\n    /** Takes n results, for use in pagination */\r\n    take?: Maybe<Scalars['Int']>;\r\n    /** Specifies which properties to sort the results by */\r\n    sort?: Maybe<FacetSortParameter>;\r\n    /** Allows the results to be filtered */\r\n    filter?: Maybe<FacetFilterParameter>;\r\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\r\n    filterOperator?: Maybe<LogicalOperator>;\r\n};\r\n\r\nexport type FacetSortParameter = {\r\n    id?: Maybe<SortOrder>;\r\n    createdAt?: Maybe<SortOrder>;\r\n    updatedAt?: Maybe<SortOrder>;\r\n    name?: Maybe<SortOrder>;\r\n    code?: Maybe<SortOrder>;\r\n};\r\n\r\nexport type FacetTranslation = {\r\n    __typename?: 'FacetTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n};\r\n\r\nexport type FacetValue = Node & {\r\n    __typename?: 'FacetValue';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    facet: Facet;\r\n    name: Scalars['String'];\r\n    code: Scalars['String'];\r\n    translations: Array<FacetValueTranslation>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\n/**\r\n * Used to construct boolean expressions for filtering search results\r\n * by FacetValue ID. Examples:\r\n *\r\n * * ID=1 OR ID=2: `{ facetValueFilters: [{ or: [1,2] }] }`\r\n * * ID=1 AND ID=2: `{ facetValueFilters: [{ and: 1 }, { and: 2 }] }`\r\n * * ID=1 AND (ID=2 OR ID=3): `{ facetValueFilters: [{ and: 1 }, { or: [2,3] }] }`\r\n */\r\nexport type FacetValueFilterInput = {\r\n    and?: Maybe<Scalars['ID']>;\r\n    or?: Maybe<Array<Scalars['ID']>>;\r\n};\r\n\r\n/**\r\n * Which FacetValues are present in the products returned\r\n * by the search, and in what quantity.\r\n */\r\nexport type FacetValueResult = {\r\n    __typename?: 'FacetValueResult';\r\n    facetValue: FacetValue;\r\n    count: Scalars['Int'];\r\n};\r\n\r\nexport type FacetValueTranslation = {\r\n    __typename?: 'FacetValueTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n};\r\n\r\nexport type FloatCustomFieldConfig = CustomField & {\r\n    __typename?: 'FloatCustomFieldConfig';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    min?: Maybe<Scalars['Float']>;\r\n    max?: Maybe<Scalars['Float']>;\r\n    step?: Maybe<Scalars['Float']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type Fulfillment = Node & {\r\n    __typename?: 'Fulfillment';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    orderItems: Array<OrderItem>;\r\n    state: Scalars['String'];\r\n    method: Scalars['String'];\r\n    trackingCode?: Maybe<Scalars['String']>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport enum GlobalFlag {\r\n    TRUE = 'TRUE',\r\n    FALSE = 'FALSE',\r\n    INHERIT = 'INHERIT',\r\n}\r\n\r\nexport type HistoryEntry = Node & {\r\n    __typename?: 'HistoryEntry';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    type: HistoryEntryType;\r\n    data: Scalars['JSON'];\r\n};\r\n\r\nexport type HistoryEntryFilterParameter = {\r\n    id?: Maybe<IdOperators>;\r\n    createdAt?: Maybe<DateOperators>;\r\n    updatedAt?: Maybe<DateOperators>;\r\n    type?: Maybe<StringOperators>;\r\n};\r\n\r\nexport type HistoryEntryList = PaginatedList & {\r\n    __typename?: 'HistoryEntryList';\r\n    items: Array<HistoryEntry>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type HistoryEntryListOptions = {\r\n    /** Skips the first n results, for use in pagination */\r\n    skip?: Maybe<Scalars['Int']>;\r\n    /** Takes n results, for use in pagination */\r\n    take?: Maybe<Scalars['Int']>;\r\n    /** Specifies which properties to sort the results by */\r\n    sort?: Maybe<HistoryEntrySortParameter>;\r\n    /** Allows the results to be filtered */\r\n    filter?: Maybe<HistoryEntryFilterParameter>;\r\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\r\n    filterOperator?: Maybe<LogicalOperator>;\r\n};\r\n\r\nexport type HistoryEntrySortParameter = {\r\n    id?: Maybe<SortOrder>;\r\n    createdAt?: Maybe<SortOrder>;\r\n    updatedAt?: Maybe<SortOrder>;\r\n};\r\n\r\nexport enum HistoryEntryType {\r\n    CUSTOMER_REGISTERED = 'CUSTOMER_REGISTERED',\r\n    CUSTOMER_VERIFIED = 'CUSTOMER_VERIFIED',\r\n    CUSTOMER_DETAIL_UPDATED = 'CUSTOMER_DETAIL_UPDATED',\r\n    CUSTOMER_ADDED_TO_GROUP = 'CUSTOMER_ADDED_TO_GROUP',\r\n    CUSTOMER_REMOVED_FROM_GROUP = 'CUSTOMER_REMOVED_FROM_GROUP',\r\n    CUSTOMER_ADDRESS_CREATED = 'CUSTOMER_ADDRESS_CREATED',\r\n    CUSTOMER_ADDRESS_UPDATED = 'CUSTOMER_ADDRESS_UPDATED',\r\n    CUSTOMER_ADDRESS_DELETED = 'CUSTOMER_ADDRESS_DELETED',\r\n    CUSTOMER_PASSWORD_UPDATED = 'CUSTOMER_PASSWORD_UPDATED',\r\n    CUSTOMER_PASSWORD_RESET_REQUESTED = 'CUSTOMER_PASSWORD_RESET_REQUESTED',\r\n    CUSTOMER_PASSWORD_RESET_VERIFIED = 'CUSTOMER_PASSWORD_RESET_VERIFIED',\r\n    CUSTOMER_EMAIL_UPDATE_REQUESTED = 'CUSTOMER_EMAIL_UPDATE_REQUESTED',\r\n    CUSTOMER_EMAIL_UPDATE_VERIFIED = 'CUSTOMER_EMAIL_UPDATE_VERIFIED',\r\n    CUSTOMER_NOTE = 'CUSTOMER_NOTE',\r\n    ORDER_STATE_TRANSITION = 'ORDER_STATE_TRANSITION',\r\n    ORDER_PAYMENT_TRANSITION = 'ORDER_PAYMENT_TRANSITION',\r\n    ORDER_FULFILLMENT = 'ORDER_FULFILLMENT',\r\n    ORDER_CANCELLATION = 'ORDER_CANCELLATION',\r\n    ORDER_REFUND_TRANSITION = 'ORDER_REFUND_TRANSITION',\r\n    ORDER_FULFILLMENT_TRANSITION = 'ORDER_FULFILLMENT_TRANSITION',\r\n    ORDER_NOTE = 'ORDER_NOTE',\r\n    ORDER_COUPON_APPLIED = 'ORDER_COUPON_APPLIED',\r\n    ORDER_COUPON_REMOVED = 'ORDER_COUPON_REMOVED',\r\n    ORDER_MODIFIED = 'ORDER_MODIFIED',\r\n}\r\n\r\n/** Operators for filtering on a list of ID fields */\r\nexport type IdListOperators = {\r\n    inList: Scalars['ID'];\r\n};\r\n\r\n/** Operators for filtering on an ID field */\r\nexport type IdOperators = {\r\n    eq?: Maybe<Scalars['String']>;\r\n    notEq?: Maybe<Scalars['String']>;\r\n    in?: Maybe<Array<Scalars['String']>>;\r\n    notIn?: Maybe<Array<Scalars['String']>>;\r\n};\r\n\r\n/**\r\n * Returned if the token used to change a Customer's email address is valid, but has\r\n * expired according to the `verificationTokenDuration` setting in the AuthOptions.\r\n */\r\nexport type IdentifierChangeTokenExpiredError = ErrorResult & {\r\n    __typename?: 'IdentifierChangeTokenExpiredError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/**\r\n * Returned if the token used to change a Customer's email address is either\r\n * invalid or does not match any expected tokens.\r\n */\r\nexport type IdentifierChangeTokenInvalidError = ErrorResult & {\r\n    __typename?: 'IdentifierChangeTokenInvalidError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/** Returned when attempting to add a Payment using a PaymentMethod for which the Order is not eligible. */\r\nexport type IneligiblePaymentMethodError = ErrorResult & {\r\n    __typename?: 'IneligiblePaymentMethodError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    eligibilityCheckerMessage?: Maybe<Scalars['String']>;\r\n};\r\n\r\n/** Returned when attempting to set a ShippingMethod for which the Order is not eligible */\r\nexport type IneligibleShippingMethodError = ErrorResult & {\r\n    __typename?: 'IneligibleShippingMethodError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/** Returned when attempting to add more items to the Order than are available */\r\nexport type InsufficientStockError = ErrorResult & {\r\n    __typename?: 'InsufficientStockError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    quantityAvailable: Scalars['Int'];\r\n    order: Order;\r\n};\r\n\r\nexport type IntCustomFieldConfig = CustomField & {\r\n    __typename?: 'IntCustomFieldConfig';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    min?: Maybe<Scalars['Int']>;\r\n    max?: Maybe<Scalars['Int']>;\r\n    step?: Maybe<Scalars['Int']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\n/** Returned if the user authentication credentials are not valid */\r\nexport type InvalidCredentialsError = ErrorResult & {\r\n    __typename?: 'InvalidCredentialsError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    authenticationError: Scalars['String'];\r\n};\r\n\r\n/**\r\n * @description\r\n * Languages in the form of a ISO 639-1 language code with optional\r\n * region or script modifier (e.g. de_AT). The selection available is based\r\n * on the [Unicode CLDR summary list](https://unicode-org.github.io/cldr-staging/charts/37/summary/root.html)\r\n * and includes the major spoken languages of the world and any widely-used variants.\r\n *\r\n * @docsCategory common\r\n */\r\nexport enum LanguageCode {\r\n    /** Afrikaans */\r\n    af = 'af',\r\n    /** Akan */\r\n    ak = 'ak',\r\n    /** Albanian */\r\n    sq = 'sq',\r\n    /** Amharic */\r\n    am = 'am',\r\n    /** Arabic */\r\n    ar = 'ar',\r\n    /** Armenian */\r\n    hy = 'hy',\r\n    /** Assamese */\r\n    as = 'as',\r\n    /** Azerbaijani */\r\n    az = 'az',\r\n    /** Bambara */\r\n    bm = 'bm',\r\n    /** Bangla */\r\n    bn = 'bn',\r\n    /** Basque */\r\n    eu = 'eu',\r\n    /** Belarusian */\r\n    be = 'be',\r\n    /** Bosnian */\r\n    bs = 'bs',\r\n    /** Breton */\r\n    br = 'br',\r\n    /** Bulgarian */\r\n    bg = 'bg',\r\n    /** Burmese */\r\n    my = 'my',\r\n    /** Catalan */\r\n    ca = 'ca',\r\n    /** Chechen */\r\n    ce = 'ce',\r\n    /** Chinese */\r\n    zh = 'zh',\r\n    /** Simplified Chinese */\r\n    zh_Hans = 'zh_Hans',\r\n    /** Traditional Chinese */\r\n    zh_Hant = 'zh_Hant',\r\n    /** Church Slavic */\r\n    cu = 'cu',\r\n    /** Cornish */\r\n    kw = 'kw',\r\n    /** Corsican */\r\n    co = 'co',\r\n    /** Croatian */\r\n    hr = 'hr',\r\n    /** Czech */\r\n    cs = 'cs',\r\n    /** Danish */\r\n    da = 'da',\r\n    /** Dutch */\r\n    nl = 'nl',\r\n    /** Flemish */\r\n    nl_BE = 'nl_BE',\r\n    /** Dzongkha */\r\n    dz = 'dz',\r\n    /** English */\r\n    en = 'en',\r\n    /** Australian English */\r\n    en_AU = 'en_AU',\r\n    /** Canadian English */\r\n    en_CA = 'en_CA',\r\n    /** British English */\r\n    en_GB = 'en_GB',\r\n    /** American English */\r\n    en_US = 'en_US',\r\n    /** Esperanto */\r\n    eo = 'eo',\r\n    /** Estonian */\r\n    et = 'et',\r\n    /** Ewe */\r\n    ee = 'ee',\r\n    /** Faroese */\r\n    fo = 'fo',\r\n    /** Finnish */\r\n    fi = 'fi',\r\n    /** French */\r\n    fr = 'fr',\r\n    /** Canadian French */\r\n    fr_CA = 'fr_CA',\r\n    /** Swiss French */\r\n    fr_CH = 'fr_CH',\r\n    /** Fulah */\r\n    ff = 'ff',\r\n    /** Galician */\r\n    gl = 'gl',\r\n    /** Ganda */\r\n    lg = 'lg',\r\n    /** Georgian */\r\n    ka = 'ka',\r\n    /** German */\r\n    de = 'de',\r\n    /** Austrian German */\r\n    de_AT = 'de_AT',\r\n    /** Swiss High German */\r\n    de_CH = 'de_CH',\r\n    /** Greek */\r\n    el = 'el',\r\n    /** Gujarati */\r\n    gu = 'gu',\r\n    /** Haitian Creole */\r\n    ht = 'ht',\r\n    /** Hausa */\r\n    ha = 'ha',\r\n    /** Hebrew */\r\n    he = 'he',\r\n    /** Hindi */\r\n    hi = 'hi',\r\n    /** Hungarian */\r\n    hu = 'hu',\r\n    /** Icelandic */\r\n    is = 'is',\r\n    /** Igbo */\r\n    ig = 'ig',\r\n    /** Indonesian */\r\n    id = 'id',\r\n    /** Interlingua */\r\n    ia = 'ia',\r\n    /** Irish */\r\n    ga = 'ga',\r\n    /** Italian */\r\n    it = 'it',\r\n    /** Japanese */\r\n    ja = 'ja',\r\n    /** Javanese */\r\n    jv = 'jv',\r\n    /** Kalaallisut */\r\n    kl = 'kl',\r\n    /** Kannada */\r\n    kn = 'kn',\r\n    /** Kashmiri */\r\n    ks = 'ks',\r\n    /** Kazakh */\r\n    kk = 'kk',\r\n    /** Khmer */\r\n    km = 'km',\r\n    /** Kikuyu */\r\n    ki = 'ki',\r\n    /** Kinyarwanda */\r\n    rw = 'rw',\r\n    /** Korean */\r\n    ko = 'ko',\r\n    /** Kurdish */\r\n    ku = 'ku',\r\n    /** Kyrgyz */\r\n    ky = 'ky',\r\n    /** Lao */\r\n    lo = 'lo',\r\n    /** Latin */\r\n    la = 'la',\r\n    /** Latvian */\r\n    lv = 'lv',\r\n    /** Lingala */\r\n    ln = 'ln',\r\n    /** Lithuanian */\r\n    lt = 'lt',\r\n    /** Luba-Katanga */\r\n    lu = 'lu',\r\n    /** Luxembourgish */\r\n    lb = 'lb',\r\n    /** Macedonian */\r\n    mk = 'mk',\r\n    /** Malagasy */\r\n    mg = 'mg',\r\n    /** Malay */\r\n    ms = 'ms',\r\n    /** Malayalam */\r\n    ml = 'ml',\r\n    /** Maltese */\r\n    mt = 'mt',\r\n    /** Manx */\r\n    gv = 'gv',\r\n    /** Maori */\r\n    mi = 'mi',\r\n    /** Marathi */\r\n    mr = 'mr',\r\n    /** Mongolian */\r\n    mn = 'mn',\r\n    /** Nepali */\r\n    ne = 'ne',\r\n    /** North Ndebele */\r\n    nd = 'nd',\r\n    /** Northern Sami */\r\n    se = 'se',\r\n    /** Norwegian Bokmål */\r\n    nb = 'nb',\r\n    /** Norwegian Nynorsk */\r\n    nn = 'nn',\r\n    /** Nyanja */\r\n    ny = 'ny',\r\n    /** Odia */\r\n    or = 'or',\r\n    /** Oromo */\r\n    om = 'om',\r\n    /** Ossetic */\r\n    os = 'os',\r\n    /** Pashto */\r\n    ps = 'ps',\r\n    /** Persian */\r\n    fa = 'fa',\r\n    /** Dari */\r\n    fa_AF = 'fa_AF',\r\n    /** Polish */\r\n    pl = 'pl',\r\n    /** Portuguese */\r\n    pt = 'pt',\r\n    /** Brazilian Portuguese */\r\n    pt_BR = 'pt_BR',\r\n    /** European Portuguese */\r\n    pt_PT = 'pt_PT',\r\n    /** Punjabi */\r\n    pa = 'pa',\r\n    /** Quechua */\r\n    qu = 'qu',\r\n    /** Romanian */\r\n    ro = 'ro',\r\n    /** Moldavian */\r\n    ro_MD = 'ro_MD',\r\n    /** Romansh */\r\n    rm = 'rm',\r\n    /** Rundi */\r\n    rn = 'rn',\r\n    /** Russian */\r\n    ru = 'ru',\r\n    /** Samoan */\r\n    sm = 'sm',\r\n    /** Sango */\r\n    sg = 'sg',\r\n    /** Sanskrit */\r\n    sa = 'sa',\r\n    /** Scottish Gaelic */\r\n    gd = 'gd',\r\n    /** Serbian */\r\n    sr = 'sr',\r\n    /** Shona */\r\n    sn = 'sn',\r\n    /** Sichuan Yi */\r\n    ii = 'ii',\r\n    /** Sindhi */\r\n    sd = 'sd',\r\n    /** Sinhala */\r\n    si = 'si',\r\n    /** Slovak */\r\n    sk = 'sk',\r\n    /** Slovenian */\r\n    sl = 'sl',\r\n    /** Somali */\r\n    so = 'so',\r\n    /** Southern Sotho */\r\n    st = 'st',\r\n    /** Spanish */\r\n    es = 'es',\r\n    /** European Spanish */\r\n    es_ES = 'es_ES',\r\n    /** Mexican Spanish */\r\n    es_MX = 'es_MX',\r\n    /** Sundanese */\r\n    su = 'su',\r\n    /** Swahili */\r\n    sw = 'sw',\r\n    /** Congo Swahili */\r\n    sw_CD = 'sw_CD',\r\n    /** Swedish */\r\n    sv = 'sv',\r\n    /** Tajik */\r\n    tg = 'tg',\r\n    /** Tamil */\r\n    ta = 'ta',\r\n    /** Tatar */\r\n    tt = 'tt',\r\n    /** Telugu */\r\n    te = 'te',\r\n    /** Thai */\r\n    th = 'th',\r\n    /** Tibetan */\r\n    bo = 'bo',\r\n    /** Tigrinya */\r\n    ti = 'ti',\r\n    /** Tongan */\r\n    to = 'to',\r\n    /** Turkish */\r\n    tr = 'tr',\r\n    /** Turkmen */\r\n    tk = 'tk',\r\n    /** Ukrainian */\r\n    uk = 'uk',\r\n    /** Urdu */\r\n    ur = 'ur',\r\n    /** Uyghur */\r\n    ug = 'ug',\r\n    /** Uzbek */\r\n    uz = 'uz',\r\n    /** Vietnamese */\r\n    vi = 'vi',\r\n    /** Volapük */\r\n    vo = 'vo',\r\n    /** Welsh */\r\n    cy = 'cy',\r\n    /** Western Frisian */\r\n    fy = 'fy',\r\n    /** Wolof */\r\n    wo = 'wo',\r\n    /** Xhosa */\r\n    xh = 'xh',\r\n    /** Yiddish */\r\n    yi = 'yi',\r\n    /** Yoruba */\r\n    yo = 'yo',\r\n    /** Zulu */\r\n    zu = 'zu',\r\n}\r\n\r\nexport type LocaleStringCustomFieldConfig = CustomField & {\r\n    __typename?: 'LocaleStringCustomFieldConfig';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    length?: Maybe<Scalars['Int']>;\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    pattern?: Maybe<Scalars['String']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type LocalizedString = {\r\n    __typename?: 'LocalizedString';\r\n    languageCode: LanguageCode;\r\n    value: Scalars['String'];\r\n};\r\n\r\nexport enum LogicalOperator {\r\n    AND = 'AND',\r\n    OR = 'OR',\r\n}\r\n\r\n/** Returned when attempting to register or verify a customer account without a password, when one is required. */\r\nexport type MissingPasswordError = ErrorResult & {\r\n    __typename?: 'MissingPasswordError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\nexport type Mutation = {\r\n    __typename?: 'Mutation';\r\n    /** Adds an item to the order. If custom fields are defined on the OrderLine entity, a third argument 'customFields' will be available. */\r\n    addItemToOrder: UpdateOrderItemsResult;\r\n    /** Remove an OrderLine from the Order */\r\n    removeOrderLine: RemoveOrderItemsResult;\r\n    /** Remove all OrderLine from the Order */\r\n    removeAllOrderLines: RemoveOrderItemsResult;\r\n    /** Adjusts an OrderLine. If custom fields are defined on the OrderLine entity, a third argument 'customFields' of type `OrderLineCustomFieldsInput` will be available. */\r\n    adjustOrderLine: UpdateOrderItemsResult;\r\n    /** Applies the given coupon code to the active Order */\r\n    applyCouponCode: ApplyCouponCodeResult;\r\n    /** Removes the given coupon code from the active Order */\r\n    removeCouponCode?: Maybe<Order>;\r\n    /** Transitions an Order to a new state. Valid next states can be found by querying `nextOrderStates` */\r\n    transitionOrderToState?: Maybe<TransitionOrderToStateResult>;\r\n    /** Sets the shipping address for this order */\r\n    setOrderShippingAddress: ActiveOrderResult;\r\n    /** Sets the billing address for this order */\r\n    setOrderBillingAddress: ActiveOrderResult;\r\n    /** Allows any custom fields to be set for the active order */\r\n    setOrderCustomFields: ActiveOrderResult;\r\n    /** Sets the shipping method by id, which can be obtained with the `eligibleShippingMethods` query */\r\n    setOrderShippingMethod: SetOrderShippingMethodResult;\r\n    /** Add a Payment to the Order */\r\n    addPaymentToOrder: AddPaymentToOrderResult;\r\n    /** Set the Customer for the Order. Required only if the Customer is not currently logged in */\r\n    setCustomerForOrder: SetCustomerForOrderResult;\r\n    /** Authenticates the user using the native authentication strategy. This mutation is an alias for `authenticate({ native: { ... }})` */\r\n    login: NativeAuthenticationResult;\r\n    /** Authenticates the user using a named authentication strategy */\r\n    authenticate: AuthenticationResult;\r\n    /** End the current authenticated session */\r\n    logout: Success;\r\n    /**\r\n     * Register a Customer account with the given credentials. There are three possible registration flows:\r\n     *\r\n     * _If `authOptions.requireVerification` is set to `true`:_\r\n     *\r\n     * 1. **The Customer is registered _with_ a password**. A verificationToken will be created (and typically emailed to the Customer). That\r\n     *    verificationToken would then be passed to the `verifyCustomerAccount` mutation _without_ a password. The Customer is then\r\n     *    verified and authenticated in one step.\r\n     * 2. **The Customer is registered _without_ a password**. A verificationToken will be created (and typically emailed to the Customer). That\r\n     *    verificationToken would then be passed to the `verifyCustomerAccount` mutation _with_ the chosen password of the Customer. The Customer is then\r\n     *    verified and authenticated in one step.\r\n     *\r\n     * _If `authOptions.requireVerification` is set to `false`:_\r\n     *\r\n     * 3. The Customer _must_ be registered _with_ a password. No further action is needed - the Customer is able to authenticate immediately.\r\n     */\r\n    registerCustomerAccount: RegisterCustomerAccountResult;\r\n    /** Regenerate and send a verification token for a new Customer registration. Only applicable if `authOptions.requireVerification` is set to true. */\r\n    refreshCustomerVerification: RefreshCustomerVerificationResult;\r\n    /** Update an existing Customer */\r\n    updateCustomer: Customer;\r\n    /** Create a new Customer Address */\r\n    createCustomerAddress: Address;\r\n    /** Update an existing Address */\r\n    updateCustomerAddress: Address;\r\n    /** Delete an existing Address */\r\n    deleteCustomerAddress: Success;\r\n    /**\r\n     * Verify a Customer email address with the token sent to that address. Only applicable if `authOptions.requireVerification` is set to true.\r\n     *\r\n     * If the Customer was not registered with a password in the `registerCustomerAccount` mutation, the password _must_ be\r\n     * provided here.\r\n     */\r\n    verifyCustomerAccount: VerifyCustomerAccountResult;\r\n    /** Update the password of the active Customer */\r\n    updateCustomerPassword: UpdateCustomerPasswordResult;\r\n    /**\r\n     * Request to update the emailAddress of the active Customer. If `authOptions.requireVerification` is enabled\r\n     * (as is the default), then the `identifierChangeToken` will be assigned to the current User and\r\n     * a IdentifierChangeRequestEvent will be raised. This can then be used e.g. by the EmailPlugin to email\r\n     * that verification token to the Customer, which is then used to verify the change of email address.\r\n     */\r\n    requestUpdateCustomerEmailAddress: RequestUpdateCustomerEmailAddressResult;\r\n    /**\r\n     * Confirm the update of the emailAddress with the provided token, which has been generated by the\r\n     * `requestUpdateCustomerEmailAddress` mutation.\r\n     */\r\n    updateCustomerEmailAddress: UpdateCustomerEmailAddressResult;\r\n    /** Requests a password reset email to be sent */\r\n    requestPasswordReset?: Maybe<RequestPasswordResetResult>;\r\n    /** Resets a Customer's password based on the provided token */\r\n    resetPassword: ResetPasswordResult;\r\n};\r\n\r\nexport type MutationAddItemToOrderArgs = {\r\n    productVariantId: Scalars['ID'];\r\n    quantity: Scalars['Int'];\r\n};\r\n\r\nexport type MutationRemoveOrderLineArgs = {\r\n    orderLineId: Scalars['ID'];\r\n};\r\n\r\nexport type MutationAdjustOrderLineArgs = {\r\n    orderLineId: Scalars['ID'];\r\n    quantity: Scalars['Int'];\r\n};\r\n\r\nexport type MutationApplyCouponCodeArgs = {\r\n    couponCode: Scalars['String'];\r\n};\r\n\r\nexport type MutationRemoveCouponCodeArgs = {\r\n    couponCode: Scalars['String'];\r\n};\r\n\r\nexport type MutationTransitionOrderToStateArgs = {\r\n    state: Scalars['String'];\r\n};\r\n\r\nexport type MutationSetOrderShippingAddressArgs = {\r\n    input: CreateAddressInput;\r\n};\r\n\r\nexport type MutationSetOrderBillingAddressArgs = {\r\n    input: CreateAddressInput;\r\n};\r\n\r\nexport type MutationSetOrderCustomFieldsArgs = {\r\n    input: UpdateOrderInput;\r\n};\r\n\r\nexport type MutationSetOrderShippingMethodArgs = {\r\n    shippingMethodId: Scalars['ID'];\r\n};\r\n\r\nexport type MutationAddPaymentToOrderArgs = {\r\n    input: PaymentInput;\r\n};\r\n\r\nexport type MutationSetCustomerForOrderArgs = {\r\n    input: CreateCustomerInput;\r\n};\r\n\r\nexport type MutationLoginArgs = {\r\n    username: Scalars['String'];\r\n    password: Scalars['String'];\r\n    rememberMe?: Maybe<Scalars['Boolean']>;\r\n};\r\n\r\nexport type MutationAuthenticateArgs = {\r\n    input: AuthenticationInput;\r\n    rememberMe?: Maybe<Scalars['Boolean']>;\r\n};\r\n\r\nexport type MutationRegisterCustomerAccountArgs = {\r\n    input: RegisterCustomerInput;\r\n};\r\n\r\nexport type MutationRefreshCustomerVerificationArgs = {\r\n    emailAddress: Scalars['String'];\r\n};\r\n\r\nexport type MutationUpdateCustomerArgs = {\r\n    input: UpdateCustomerInput;\r\n};\r\n\r\nexport type MutationCreateCustomerAddressArgs = {\r\n    input: CreateAddressInput;\r\n};\r\n\r\nexport type MutationUpdateCustomerAddressArgs = {\r\n    input: UpdateAddressInput;\r\n};\r\n\r\nexport type MutationDeleteCustomerAddressArgs = {\r\n    id: Scalars['ID'];\r\n};\r\n\r\nexport type MutationVerifyCustomerAccountArgs = {\r\n    token: Scalars['String'];\r\n    password?: Maybe<Scalars['String']>;\r\n};\r\n\r\nexport type MutationUpdateCustomerPasswordArgs = {\r\n    currentPassword: Scalars['String'];\r\n    newPassword: Scalars['String'];\r\n};\r\n\r\nexport type MutationRequestUpdateCustomerEmailAddressArgs = {\r\n    password: Scalars['String'];\r\n    newEmailAddress: Scalars['String'];\r\n};\r\n\r\nexport type MutationUpdateCustomerEmailAddressArgs = {\r\n    token: Scalars['String'];\r\n};\r\n\r\nexport type MutationRequestPasswordResetArgs = {\r\n    emailAddress: Scalars['String'];\r\n};\r\n\r\nexport type MutationResetPasswordArgs = {\r\n    token: Scalars['String'];\r\n    password: Scalars['String'];\r\n};\r\n\r\nexport type NativeAuthInput = {\r\n    username: Scalars['String'];\r\n    password: Scalars['String'];\r\n};\r\n\r\n/** Returned when attempting an operation that relies on the NativeAuthStrategy, if that strategy is not configured. */\r\nexport type NativeAuthStrategyError = ErrorResult & {\r\n    __typename?: 'NativeAuthStrategyError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\nexport type NativeAuthenticationResult =\r\n    | CurrentUser\r\n    | InvalidCredentialsError\r\n    | NotVerifiedError\r\n    | NativeAuthStrategyError;\r\n\r\n/** Returned when attempting to set a negative OrderLine quantity. */\r\nexport type NegativeQuantityError = ErrorResult & {\r\n    __typename?: 'NegativeQuantityError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/**\r\n * Returned when invoking a mutation which depends on there being an active Order on the\r\n * current session.\r\n */\r\nexport type NoActiveOrderError = ErrorResult & {\r\n    __typename?: 'NoActiveOrderError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\nexport type Node = {\r\n    id: Scalars['ID'];\r\n};\r\n\r\n/**\r\n * Returned if `authOptions.requireVerification` is set to `true` (which is the default)\r\n * and an unverified user attempts to authenticate.\r\n */\r\nexport type NotVerifiedError = ErrorResult & {\r\n    __typename?: 'NotVerifiedError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/** Operators for filtering on a list of Number fields */\r\nexport type NumberListOperators = {\r\n    inList: Scalars['Float'];\r\n};\r\n\r\n/** Operators for filtering on a Int or Float field */\r\nexport type NumberOperators = {\r\n    eq?: Maybe<Scalars['Float']>;\r\n    lt?: Maybe<Scalars['Float']>;\r\n    lte?: Maybe<Scalars['Float']>;\r\n    gt?: Maybe<Scalars['Float']>;\r\n    gte?: Maybe<Scalars['Float']>;\r\n    between?: Maybe<NumberRange>;\r\n};\r\n\r\nexport type NumberRange = {\r\n    start: Scalars['Float'];\r\n    end: Scalars['Float'];\r\n};\r\n\r\nexport type Order = Node & {\r\n    __typename?: 'Order';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    /**\r\n     * The date & time that the Order was placed, i.e. the Customer\r\n     * completed the checkout and the Order is no longer \"active\"\r\n     */\r\n    orderPlacedAt?: Maybe<Scalars['DateTime']>;\r\n    /** A unique code for the Order */\r\n    code: Scalars['String'];\r\n    state: Scalars['String'];\r\n    /** An order is active as long as the payment process has not been completed */\r\n    active: Scalars['Boolean'];\r\n    customer?: Maybe<Customer>;\r\n    shippingAddress?: Maybe<OrderAddress>;\r\n    billingAddress?: Maybe<OrderAddress>;\r\n    lines: Array<OrderLine>;\r\n    /**\r\n     * Surcharges are arbitrary modifications to the Order total which are neither\r\n     * ProductVariants nor discounts resulting from applied Promotions. For example,\r\n     * one-off discounts based on customer interaction, or surcharges based on payment\r\n     * methods.\r\n     */\r\n    surcharges: Array<Surcharge>;\r\n    discounts: Array<Discount>;\r\n    /** An array of all coupon codes applied to the Order */\r\n    couponCodes: Array<Scalars['String']>;\r\n    /** Promotions applied to the order. Only gets populated after the payment process has completed. */\r\n    promotions: Array<Promotion>;\r\n    payments?: Maybe<Array<Payment>>;\r\n    fulfillments?: Maybe<Array<Fulfillment>>;\r\n    totalQuantity: Scalars['Int'];\r\n    /**\r\n     * The subTotal is the total of all OrderLines in the Order. This figure also includes any Order-level\r\n     * discounts which have been prorated (proportionally distributed) amongst the OrderItems.\r\n     * To get a total of all OrderLines which does not account for prorated discounts, use the\r\n     * sum of `OrderLine.discountedLinePrice` values.\r\n     */\r\n    subTotal: Scalars['Int'];\r\n    /** Same as subTotal, but inclusive of tax */\r\n    subTotalWithTax: Scalars['Int'];\r\n    currencyCode: CurrencyCode;\r\n    shippingLines: Array<ShippingLine>;\r\n    shipping: Scalars['Int'];\r\n    shippingWithTax: Scalars['Int'];\r\n    /** Equal to subTotal plus shipping */\r\n    total: Scalars['Int'];\r\n    /** The final payable amount. Equal to subTotalWithTax plus shippingWithTax */\r\n    totalWithTax: Scalars['Int'];\r\n    /** A summary of the taxes being applied to this Order */\r\n    taxSummary: Array<OrderTaxSummary>;\r\n    history: HistoryEntryList;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type OrderHistoryArgs = {\r\n    options?: Maybe<HistoryEntryListOptions>;\r\n};\r\n\r\nexport type OrderAddress = {\r\n    __typename?: 'OrderAddress';\r\n    fullName?: Maybe<Scalars['String']>;\r\n    company?: Maybe<Scalars['String']>;\r\n    streetLine1?: Maybe<Scalars['String']>;\r\n    streetLine2?: Maybe<Scalars['String']>;\r\n    city?: Maybe<Scalars['String']>;\r\n    province?: Maybe<Scalars['String']>;\r\n    postalCode?: Maybe<Scalars['String']>;\r\n    country?: Maybe<Scalars['String']>;\r\n    countryCode?: Maybe<Scalars['String']>;\r\n    phoneNumber?: Maybe<Scalars['String']>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type OrderFilterParameter = {\r\n    id?: Maybe<IdOperators>;\r\n    createdAt?: Maybe<DateOperators>;\r\n    updatedAt?: Maybe<DateOperators>;\r\n    orderPlacedAt?: Maybe<DateOperators>;\r\n    code?: Maybe<StringOperators>;\r\n    state?: Maybe<StringOperators>;\r\n    active?: Maybe<BooleanOperators>;\r\n    totalQuantity?: Maybe<NumberOperators>;\r\n    subTotal?: Maybe<NumberOperators>;\r\n    subTotalWithTax?: Maybe<NumberOperators>;\r\n    currencyCode?: Maybe<StringOperators>;\r\n    shipping?: Maybe<NumberOperators>;\r\n    shippingWithTax?: Maybe<NumberOperators>;\r\n    total?: Maybe<NumberOperators>;\r\n    totalWithTax?: Maybe<NumberOperators>;\r\n};\r\n\r\nexport type OrderItem = Node & {\r\n    __typename?: 'OrderItem';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    cancelled: Scalars['Boolean'];\r\n    /** The price of a single unit, excluding tax and discounts */\r\n    unitPrice: Scalars['Int'];\r\n    /** The price of a single unit, including tax but excluding discounts */\r\n    unitPriceWithTax: Scalars['Int'];\r\n    /**\r\n     * The price of a single unit including discounts, excluding tax.\r\n     *\r\n     * If Order-level discounts have been applied, this will not be the\r\n     * actual taxable unit price (see `proratedUnitPrice`), but is generally the\r\n     * correct price to display to customers to avoid confusion\r\n     * about the internal handling of distributed Order-level discounts.\r\n     */\r\n    discountedUnitPrice: Scalars['Int'];\r\n    /** The price of a single unit including discounts and tax */\r\n    discountedUnitPriceWithTax: Scalars['Int'];\r\n    /**\r\n     * The actual unit price, taking into account both item discounts _and_ prorated (proportionally-distributed)\r\n     * Order-level discounts. This value is the true economic value of the OrderItem, and is used in tax\r\n     * and refund calculations.\r\n     */\r\n    proratedUnitPrice: Scalars['Int'];\r\n    /** The proratedUnitPrice including tax */\r\n    proratedUnitPriceWithTax: Scalars['Int'];\r\n    unitTax: Scalars['Int'];\r\n    taxRate: Scalars['Float'];\r\n    adjustments: Array<Adjustment>;\r\n    taxLines: Array<TaxLine>;\r\n    fulfillment?: Maybe<Fulfillment>;\r\n    refundId?: Maybe<Scalars['ID']>;\r\n};\r\n\r\n/** Returned when the maximum order size limit has been reached. */\r\nexport type OrderLimitError = ErrorResult & {\r\n    __typename?: 'OrderLimitError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    maxItems: Scalars['Int'];\r\n};\r\n\r\nexport type OrderLine = Node & {\r\n    __typename?: 'OrderLine';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    productVariant: ProductVariant;\r\n    featuredAsset?: Maybe<Asset>;\r\n    /** The price of a single unit, excluding tax and discounts */\r\n    unitPrice: Scalars['Int'];\r\n    /** The price of a single unit, including tax but excluding discounts */\r\n    unitPriceWithTax: Scalars['Int'];\r\n    /** Non-zero if the unitPrice has changed since it was initially added to Order */\r\n    unitPriceChangeSinceAdded: Scalars['Int'];\r\n    /** Non-zero if the unitPriceWithTax has changed since it was initially added to Order */\r\n    unitPriceWithTaxChangeSinceAdded: Scalars['Int'];\r\n    /**\r\n     * The price of a single unit including discounts, excluding tax.\r\n     *\r\n     * If Order-level discounts have been applied, this will not be the\r\n     * actual taxable unit price (see `proratedUnitPrice`), but is generally the\r\n     * correct price to display to customers to avoid confusion\r\n     * about the internal handling of distributed Order-level discounts.\r\n     */\r\n    discountedUnitPrice: Scalars['Int'];\r\n    /** The price of a single unit including discounts and tax */\r\n    discountedUnitPriceWithTax: Scalars['Int'];\r\n    /**\r\n     * The actual unit price, taking into account both item discounts _and_ prorated (proportionally-distributed)\r\n     * Order-level discounts. This value is the true economic value of the OrderItem, and is used in tax\r\n     * and refund calculations.\r\n     */\r\n    proratedUnitPrice: Scalars['Int'];\r\n    /** The proratedUnitPrice including tax */\r\n    proratedUnitPriceWithTax: Scalars['Int'];\r\n    quantity: Scalars['Int'];\r\n    items: Array<OrderItem>;\r\n    taxRate: Scalars['Float'];\r\n    /** The total price of the line excluding tax and discounts. */\r\n    linePrice: Scalars['Int'];\r\n    /** The total price of the line including tax but excluding discounts. */\r\n    linePriceWithTax: Scalars['Int'];\r\n    /** The price of the line including discounts, excluding tax */\r\n    discountedLinePrice: Scalars['Int'];\r\n    /** The price of the line including discounts and tax */\r\n    discountedLinePriceWithTax: Scalars['Int'];\r\n    /**\r\n     * The actual line price, taking into account both item discounts _and_ prorated (proportionally-distributed)\r\n     * Order-level discounts. This value is the true economic value of the OrderLine, and is used in tax\r\n     * and refund calculations.\r\n     */\r\n    proratedLinePrice: Scalars['Int'];\r\n    /** The proratedLinePrice including tax */\r\n    proratedLinePriceWithTax: Scalars['Int'];\r\n    /** The total tax on this line */\r\n    lineTax: Scalars['Int'];\r\n    discounts: Array<Discount>;\r\n    taxLines: Array<TaxLine>;\r\n    order: Order;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type OrderList = PaginatedList & {\r\n    __typename?: 'OrderList';\r\n    items: Array<Order>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type OrderListOptions = {\r\n    /** Skips the first n results, for use in pagination */\r\n    skip?: Maybe<Scalars['Int']>;\r\n    /** Takes n results, for use in pagination */\r\n    take?: Maybe<Scalars['Int']>;\r\n    /** Specifies which properties to sort the results by */\r\n    sort?: Maybe<OrderSortParameter>;\r\n    /** Allows the results to be filtered */\r\n    filter?: Maybe<OrderFilterParameter>;\r\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\r\n    filterOperator?: Maybe<LogicalOperator>;\r\n};\r\n\r\n/** Returned when attempting to modify the contents of an Order that is not in the `AddingItems` state. */\r\nexport type OrderModificationError = ErrorResult & {\r\n    __typename?: 'OrderModificationError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/** Returned when attempting to add a Payment to an Order that is not in the `ArrangingPayment` state. */\r\nexport type OrderPaymentStateError = ErrorResult & {\r\n    __typename?: 'OrderPaymentStateError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\nexport type OrderSortParameter = {\r\n    id?: Maybe<SortOrder>;\r\n    createdAt?: Maybe<SortOrder>;\r\n    updatedAt?: Maybe<SortOrder>;\r\n    orderPlacedAt?: Maybe<SortOrder>;\r\n    code?: Maybe<SortOrder>;\r\n    state?: Maybe<SortOrder>;\r\n    totalQuantity?: Maybe<SortOrder>;\r\n    subTotal?: Maybe<SortOrder>;\r\n    subTotalWithTax?: Maybe<SortOrder>;\r\n    shipping?: Maybe<SortOrder>;\r\n    shippingWithTax?: Maybe<SortOrder>;\r\n    total?: Maybe<SortOrder>;\r\n    totalWithTax?: Maybe<SortOrder>;\r\n};\r\n\r\n/** Returned if there is an error in transitioning the Order state */\r\nexport type OrderStateTransitionError = ErrorResult & {\r\n    __typename?: 'OrderStateTransitionError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    transitionError: Scalars['String'];\r\n    fromState: Scalars['String'];\r\n    toState: Scalars['String'];\r\n};\r\n\r\n/**\r\n * A summary of the taxes being applied to this order, grouped\r\n * by taxRate.\r\n */\r\nexport type OrderTaxSummary = {\r\n    __typename?: 'OrderTaxSummary';\r\n    /** A description of this tax */\r\n    description: Scalars['String'];\r\n    /** The taxRate as a percentage */\r\n    taxRate: Scalars['Float'];\r\n    /** The total net price or OrderItems to which this taxRate applies */\r\n    taxBase: Scalars['Int'];\r\n    /** The total tax being applied to the Order at this taxRate */\r\n    taxTotal: Scalars['Int'];\r\n};\r\n\r\nexport type PaginatedList = {\r\n    items: Array<Node>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\n/** Returned when attempting to verify a customer account with a password, when a password has already been set. */\r\nexport type PasswordAlreadySetError = ErrorResult & {\r\n    __typename?: 'PasswordAlreadySetError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/**\r\n * Returned if the token used to reset a Customer's password is valid, but has\r\n * expired according to the `verificationTokenDuration` setting in the AuthOptions.\r\n */\r\nexport type PasswordResetTokenExpiredError = ErrorResult & {\r\n    __typename?: 'PasswordResetTokenExpiredError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/**\r\n * Returned if the token used to reset a Customer's password is either\r\n * invalid or does not match any expected tokens.\r\n */\r\nexport type PasswordResetTokenInvalidError = ErrorResult & {\r\n    __typename?: 'PasswordResetTokenInvalidError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/** Returned when attempting to register or verify a customer account where the given password fails password validation. */\r\nexport type PasswordValidationError = ErrorResult & {\r\n    __typename?: 'PasswordValidationError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    validationErrorMessage: Scalars['String'];\r\n};\r\n\r\nexport type Payment = Node & {\r\n    __typename?: 'Payment';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    method: Scalars['String'];\r\n    amount: Scalars['Int'];\r\n    state: Scalars['String'];\r\n    transactionId?: Maybe<Scalars['String']>;\r\n    errorMessage?: Maybe<Scalars['String']>;\r\n    refunds: Array<Refund>;\r\n    metadata?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\n/** Returned when a Payment is declined by the payment provider. */\r\nexport type PaymentDeclinedError = ErrorResult & {\r\n    __typename?: 'PaymentDeclinedError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    paymentErrorMessage: Scalars['String'];\r\n};\r\n\r\n/** Returned when a Payment fails due to an error. */\r\nexport type PaymentFailedError = ErrorResult & {\r\n    __typename?: 'PaymentFailedError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n    paymentErrorMessage: Scalars['String'];\r\n};\r\n\r\n/** Passed as input to the `addPaymentToOrder` mutation. */\r\nexport type PaymentInput = {\r\n    /** This field should correspond to the `code` property of a PaymentMethod. */\r\n    method: Scalars['String'];\r\n    /**\r\n     * This field should contain arbitrary data passed to the specified PaymentMethodHandler's `createPayment()` method\r\n     * as the \"metadata\" argument. For example, it could contain an ID for the payment and other\r\n     * data generated by the payment provider.\r\n     */\r\n    metadata: Scalars['JSON'];\r\n};\r\n\r\nexport type PaymentMethod = Node & {\r\n    __typename?: 'PaymentMethod';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    name: Scalars['String'];\r\n    code: Scalars['String'];\r\n    description: Scalars['String'];\r\n    enabled: Scalars['Boolean'];\r\n    checker?: Maybe<ConfigurableOperation>;\r\n    handler: ConfigurableOperation;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type PaymentMethodQuote = {\r\n    __typename?: 'PaymentMethodQuote';\r\n    id: Scalars['ID'];\r\n    code: Scalars['String'];\r\n    name: Scalars['String'];\r\n    description: Scalars['String'];\r\n    isEligible: Scalars['Boolean'];\r\n    eligibilityMessage?: Maybe<Scalars['String']>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\n/**\r\n * @description\r\n * Permissions for administrators and customers. Used to control access to\r\n * GraphQL resolvers via the {@link Allow} decorator.\r\n *\r\n * @docsCategory common\r\n */\r\nexport enum Permission {\r\n    /** Authenticated means simply that the user is logged in */\r\n    Authenticated = 'Authenticated',\r\n    /** SuperAdmin has unrestricted access to all operations */\r\n    SuperAdmin = 'SuperAdmin',\r\n    /** Owner means the user owns this entity, e.g. a Customer's own Order */\r\n    Owner = 'Owner',\r\n    /** Public means any unauthenticated user may perform the operation */\r\n    Public = 'Public',\r\n    /** Grants permission to update GlobalSettings */\r\n    UpdateGlobalSettings = 'UpdateGlobalSettings',\r\n    /** Grants permission to create Products, Facets, Assets, Collections */\r\n    CreateCatalog = 'CreateCatalog',\r\n    /** Grants permission to read Products, Facets, Assets, Collections */\r\n    ReadCatalog = 'ReadCatalog',\r\n    /** Grants permission to update Products, Facets, Assets, Collections */\r\n    UpdateCatalog = 'UpdateCatalog',\r\n    /** Grants permission to delete Products, Facets, Assets, Collections */\r\n    DeleteCatalog = 'DeleteCatalog',\r\n    /** Grants permission to create PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings */\r\n    CreateSettings = 'CreateSettings',\r\n    /** Grants permission to read PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings */\r\n    ReadSettings = 'ReadSettings',\r\n    /** Grants permission to update PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings */\r\n    UpdateSettings = 'UpdateSettings',\r\n    /** Grants permission to delete PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings */\r\n    DeleteSettings = 'DeleteSettings',\r\n    /** Grants permission to create Administrator */\r\n    CreateAdministrator = 'CreateAdministrator',\r\n    /** Grants permission to read Administrator */\r\n    ReadAdministrator = 'ReadAdministrator',\r\n    /** Grants permission to update Administrator */\r\n    UpdateAdministrator = 'UpdateAdministrator',\r\n    /** Grants permission to delete Administrator */\r\n    DeleteAdministrator = 'DeleteAdministrator',\r\n    /** Grants permission to create Asset */\r\n    CreateAsset = 'CreateAsset',\r\n    /** Grants permission to read Asset */\r\n    ReadAsset = 'ReadAsset',\r\n    /** Grants permission to update Asset */\r\n    UpdateAsset = 'UpdateAsset',\r\n    /** Grants permission to delete Asset */\r\n    DeleteAsset = 'DeleteAsset',\r\n    /** Grants permission to create Channel */\r\n    CreateChannel = 'CreateChannel',\r\n    /** Grants permission to read Channel */\r\n    ReadChannel = 'ReadChannel',\r\n    /** Grants permission to update Channel */\r\n    UpdateChannel = 'UpdateChannel',\r\n    /** Grants permission to delete Channel */\r\n    DeleteChannel = 'DeleteChannel',\r\n    /** Grants permission to create Collection */\r\n    CreateCollection = 'CreateCollection',\r\n    /** Grants permission to read Collection */\r\n    ReadCollection = 'ReadCollection',\r\n    /** Grants permission to update Collection */\r\n    UpdateCollection = 'UpdateCollection',\r\n    /** Grants permission to delete Collection */\r\n    DeleteCollection = 'DeleteCollection',\r\n    /** Grants permission to create Country */\r\n    CreateCountry = 'CreateCountry',\r\n    /** Grants permission to read Country */\r\n    ReadCountry = 'ReadCountry',\r\n    /** Grants permission to update Country */\r\n    UpdateCountry = 'UpdateCountry',\r\n    /** Grants permission to delete Country */\r\n    DeleteCountry = 'DeleteCountry',\r\n    /** Grants permission to create Customer */\r\n    CreateCustomer = 'CreateCustomer',\r\n    /** Grants permission to read Customer */\r\n    ReadCustomer = 'ReadCustomer',\r\n    /** Grants permission to update Customer */\r\n    UpdateCustomer = 'UpdateCustomer',\r\n    /** Grants permission to delete Customer */\r\n    DeleteCustomer = 'DeleteCustomer',\r\n    /** Grants permission to create CustomerGroup */\r\n    CreateCustomerGroup = 'CreateCustomerGroup',\r\n    /** Grants permission to read CustomerGroup */\r\n    ReadCustomerGroup = 'ReadCustomerGroup',\r\n    /** Grants permission to update CustomerGroup */\r\n    UpdateCustomerGroup = 'UpdateCustomerGroup',\r\n    /** Grants permission to delete CustomerGroup */\r\n    DeleteCustomerGroup = 'DeleteCustomerGroup',\r\n    /** Grants permission to create Facet */\r\n    CreateFacet = 'CreateFacet',\r\n    /** Grants permission to read Facet */\r\n    ReadFacet = 'ReadFacet',\r\n    /** Grants permission to update Facet */\r\n    UpdateFacet = 'UpdateFacet',\r\n    /** Grants permission to delete Facet */\r\n    DeleteFacet = 'DeleteFacet',\r\n    /** Grants permission to create Order */\r\n    CreateOrder = 'CreateOrder',\r\n    /** Grants permission to read Order */\r\n    ReadOrder = 'ReadOrder',\r\n    /** Grants permission to update Order */\r\n    UpdateOrder = 'UpdateOrder',\r\n    /** Grants permission to delete Order */\r\n    DeleteOrder = 'DeleteOrder',\r\n    /** Grants permission to create PaymentMethod */\r\n    CreatePaymentMethod = 'CreatePaymentMethod',\r\n    /** Grants permission to read PaymentMethod */\r\n    ReadPaymentMethod = 'ReadPaymentMethod',\r\n    /** Grants permission to update PaymentMethod */\r\n    UpdatePaymentMethod = 'UpdatePaymentMethod',\r\n    /** Grants permission to delete PaymentMethod */\r\n    DeletePaymentMethod = 'DeletePaymentMethod',\r\n    /** Grants permission to create Product */\r\n    CreateProduct = 'CreateProduct',\r\n    /** Grants permission to read Product */\r\n    ReadProduct = 'ReadProduct',\r\n    /** Grants permission to update Product */\r\n    UpdateProduct = 'UpdateProduct',\r\n    /** Grants permission to delete Product */\r\n    DeleteProduct = 'DeleteProduct',\r\n    /** Grants permission to create Promotion */\r\n    CreatePromotion = 'CreatePromotion',\r\n    /** Grants permission to read Promotion */\r\n    ReadPromotion = 'ReadPromotion',\r\n    /** Grants permission to update Promotion */\r\n    UpdatePromotion = 'UpdatePromotion',\r\n    /** Grants permission to delete Promotion */\r\n    DeletePromotion = 'DeletePromotion',\r\n    /** Grants permission to create ShippingMethod */\r\n    CreateShippingMethod = 'CreateShippingMethod',\r\n    /** Grants permission to read ShippingMethod */\r\n    ReadShippingMethod = 'ReadShippingMethod',\r\n    /** Grants permission to update ShippingMethod */\r\n    UpdateShippingMethod = 'UpdateShippingMethod',\r\n    /** Grants permission to delete ShippingMethod */\r\n    DeleteShippingMethod = 'DeleteShippingMethod',\r\n    /** Grants permission to create Tag */\r\n    CreateTag = 'CreateTag',\r\n    /** Grants permission to read Tag */\r\n    ReadTag = 'ReadTag',\r\n    /** Grants permission to update Tag */\r\n    UpdateTag = 'UpdateTag',\r\n    /** Grants permission to delete Tag */\r\n    DeleteTag = 'DeleteTag',\r\n    /** Grants permission to create TaxCategory */\r\n    CreateTaxCategory = 'CreateTaxCategory',\r\n    /** Grants permission to read TaxCategory */\r\n    ReadTaxCategory = 'ReadTaxCategory',\r\n    /** Grants permission to update TaxCategory */\r\n    UpdateTaxCategory = 'UpdateTaxCategory',\r\n    /** Grants permission to delete TaxCategory */\r\n    DeleteTaxCategory = 'DeleteTaxCategory',\r\n    /** Grants permission to create TaxRate */\r\n    CreateTaxRate = 'CreateTaxRate',\r\n    /** Grants permission to read TaxRate */\r\n    ReadTaxRate = 'ReadTaxRate',\r\n    /** Grants permission to update TaxRate */\r\n    UpdateTaxRate = 'UpdateTaxRate',\r\n    /** Grants permission to delete TaxRate */\r\n    DeleteTaxRate = 'DeleteTaxRate',\r\n    /** Grants permission to create System */\r\n    CreateSystem = 'CreateSystem',\r\n    /** Grants permission to read System */\r\n    ReadSystem = 'ReadSystem',\r\n    /** Grants permission to update System */\r\n    UpdateSystem = 'UpdateSystem',\r\n    /** Grants permission to delete System */\r\n    DeleteSystem = 'DeleteSystem',\r\n    /** Grants permission to create Zone */\r\n    CreateZone = 'CreateZone',\r\n    /** Grants permission to read Zone */\r\n    ReadZone = 'ReadZone',\r\n    /** Grants permission to update Zone */\r\n    UpdateZone = 'UpdateZone',\r\n    /** Grants permission to delete Zone */\r\n    DeleteZone = 'DeleteZone',\r\n}\r\n\r\n/** The price range where the result has more than one price */\r\nexport type PriceRange = {\r\n    __typename?: 'PriceRange';\r\n    min: Scalars['Int'];\r\n    max: Scalars['Int'];\r\n};\r\n\r\nexport type Product = Node & {\r\n    __typename?: 'Product';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n    slug: Scalars['String'];\r\n    description: Scalars['String'];\r\n    featuredAsset?: Maybe<Asset>;\r\n    assets: Array<Asset>;\r\n    /** Returns all ProductVariants */\r\n    variants: Array<ProductVariant>;\r\n    /** Returns a paginated, sortable, filterable list of ProductVariants */\r\n    variantList: ProductVariantList;\r\n    optionGroups: Array<ProductOptionGroup>;\r\n    facetValues: Array<FacetValue>;\r\n    translations: Array<ProductTranslation>;\r\n    collections: Array<Collection>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type ProductVariantListArgs = {\r\n    options?: Maybe<ProductVariantListOptions>;\r\n};\r\n\r\nexport type ProductFilterParameter = {\r\n    id?: Maybe<IdOperators>;\r\n    createdAt?: Maybe<DateOperators>;\r\n    updatedAt?: Maybe<DateOperators>;\r\n    languageCode?: Maybe<StringOperators>;\r\n    name?: Maybe<StringOperators>;\r\n    slug?: Maybe<StringOperators>;\r\n    description?: Maybe<StringOperators>;\r\n};\r\n\r\nexport type ProductList = PaginatedList & {\r\n    __typename?: 'ProductList';\r\n    items: Array<Product>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type ProductListOptions = {\r\n    /** Skips the first n results, for use in pagination */\r\n    skip?: Maybe<Scalars['Int']>;\r\n    /** Takes n results, for use in pagination */\r\n    take?: Maybe<Scalars['Int']>;\r\n    /** Specifies which properties to sort the results by */\r\n    sort?: Maybe<ProductSortParameter>;\r\n    /** Allows the results to be filtered */\r\n    filter?: Maybe<ProductFilterParameter>;\r\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\r\n    filterOperator?: Maybe<LogicalOperator>;\r\n};\r\n\r\nexport type ProductOption = Node & {\r\n    __typename?: 'ProductOption';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    code: Scalars['String'];\r\n    name: Scalars['String'];\r\n    groupId: Scalars['ID'];\r\n    group: ProductOptionGroup;\r\n    translations: Array<ProductOptionTranslation>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type ProductOptionGroup = Node & {\r\n    __typename?: 'ProductOptionGroup';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    code: Scalars['String'];\r\n    name: Scalars['String'];\r\n    options: Array<ProductOption>;\r\n    translations: Array<ProductOptionGroupTranslation>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type ProductOptionGroupTranslation = {\r\n    __typename?: 'ProductOptionGroupTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n};\r\n\r\nexport type ProductOptionTranslation = {\r\n    __typename?: 'ProductOptionTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n};\r\n\r\nexport type ProductSortParameter = {\r\n    id?: Maybe<SortOrder>;\r\n    createdAt?: Maybe<SortOrder>;\r\n    updatedAt?: Maybe<SortOrder>;\r\n    name?: Maybe<SortOrder>;\r\n    slug?: Maybe<SortOrder>;\r\n    description?: Maybe<SortOrder>;\r\n};\r\n\r\nexport type ProductTranslation = {\r\n    __typename?: 'ProductTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n    slug: Scalars['String'];\r\n    description: Scalars['String'];\r\n};\r\n\r\nexport type ProductVariant = Node & {\r\n    __typename?: 'ProductVariant';\r\n    id: Scalars['ID'];\r\n    product: Product;\r\n    productId: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    sku: Scalars['String'];\r\n    name: Scalars['String'];\r\n    featuredAsset?: Maybe<Asset>;\r\n    assets: Array<Asset>;\r\n    price: Scalars['Int'];\r\n    currencyCode: CurrencyCode;\r\n    priceWithTax: Scalars['Int'];\r\n    stockLevel: Scalars['String'];\r\n    taxRateApplied: TaxRate;\r\n    taxCategory: TaxCategory;\r\n    options: Array<ProductOption>;\r\n    facetValues: Array<FacetValue>;\r\n    translations: Array<ProductVariantTranslation>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type ProductVariantFilterParameter = {\r\n    id?: Maybe<IdOperators>;\r\n    productId?: Maybe<IdOperators>;\r\n    createdAt?: Maybe<DateOperators>;\r\n    updatedAt?: Maybe<DateOperators>;\r\n    languageCode?: Maybe<StringOperators>;\r\n    sku?: Maybe<StringOperators>;\r\n    name?: Maybe<StringOperators>;\r\n    price?: Maybe<NumberOperators>;\r\n    currencyCode?: Maybe<StringOperators>;\r\n    priceWithTax?: Maybe<NumberOperators>;\r\n    stockLevel?: Maybe<StringOperators>;\r\n};\r\n\r\nexport type ProductVariantList = PaginatedList & {\r\n    __typename?: 'ProductVariantList';\r\n    items: Array<ProductVariant>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type ProductVariantListOptions = {\r\n    /** Skips the first n results, for use in pagination */\r\n    skip?: Maybe<Scalars['Int']>;\r\n    /** Takes n results, for use in pagination */\r\n    take?: Maybe<Scalars['Int']>;\r\n    /** Specifies which properties to sort the results by */\r\n    sort?: Maybe<ProductVariantSortParameter>;\r\n    /** Allows the results to be filtered */\r\n    filter?: Maybe<ProductVariantFilterParameter>;\r\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\r\n    filterOperator?: Maybe<LogicalOperator>;\r\n};\r\n\r\nexport type ProductVariantSortParameter = {\r\n    id?: Maybe<SortOrder>;\r\n    productId?: Maybe<SortOrder>;\r\n    createdAt?: Maybe<SortOrder>;\r\n    updatedAt?: Maybe<SortOrder>;\r\n    sku?: Maybe<SortOrder>;\r\n    name?: Maybe<SortOrder>;\r\n    price?: Maybe<SortOrder>;\r\n    priceWithTax?: Maybe<SortOrder>;\r\n    stockLevel?: Maybe<SortOrder>;\r\n};\r\n\r\nexport type ProductVariantTranslation = {\r\n    __typename?: 'ProductVariantTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n};\r\n\r\nexport type Promotion = Node & {\r\n    __typename?: 'Promotion';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    startsAt?: Maybe<Scalars['DateTime']>;\r\n    endsAt?: Maybe<Scalars['DateTime']>;\r\n    couponCode?: Maybe<Scalars['String']>;\r\n    perCustomerUsageLimit?: Maybe<Scalars['Int']>;\r\n    name: Scalars['String'];\r\n    enabled: Scalars['Boolean'];\r\n    conditions: Array<ConfigurableOperation>;\r\n    actions: Array<ConfigurableOperation>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type PromotionList = PaginatedList & {\r\n    __typename?: 'PromotionList';\r\n    items: Array<Promotion>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type Query = {\r\n    __typename?: 'Query';\r\n    /** The active Channel */\r\n    activeChannel: Channel;\r\n    /** The active Customer */\r\n    activeCustomer?: Maybe<Customer>;\r\n    /**\r\n     * The active Order. Will be `null` until an Order is created via `addItemToOrder`. Once an Order reaches the\r\n     * state of `PaymentAuthorized` or `PaymentSettled`, then that Order is no longer considered \"active\" and this\r\n     * query will once again return `null`.\r\n     */\r\n    activeOrder?: Maybe<Order>;\r\n    /** An array of supported Countries */\r\n    availableCountries: Array<Country>;\r\n    /** A list of Collections available to the shop */\r\n    collections: CollectionList;\r\n    /** Returns a Collection either by its id or slug. If neither 'id' nor 'slug' is specified, an error will result. */\r\n    collection?: Maybe<Collection>;\r\n    /** Returns a list of eligible shipping methods based on the current active Order */\r\n    eligibleShippingMethods: Array<ShippingMethodQuote>;\r\n    /** Returns a list of payment methods and their eligibility based on the current active Order */\r\n    eligiblePaymentMethods: Array<PaymentMethodQuote>;\r\n    /** A list of Facets available to the shop */\r\n    facets: FacetList;\r\n    /** Returns a Facet by its id */\r\n    facet?: Maybe<Facet>;\r\n    /** Returns information about the current authenticated User */\r\n    me?: Maybe<CurrentUser>;\r\n    /** Returns the possible next states that the activeOrder can transition to */\r\n    nextOrderStates: Array<Scalars['String']>;\r\n    /**\r\n     * Returns an Order based on the id. Note that in the Shop API, only orders belonging to the\r\n     * currently-authenticated User may be queried.\r\n     */\r\n    order?: Maybe<Order>;\r\n    /**\r\n     * Returns an Order based on the order `code`. For guest Orders (i.e. Orders placed by non-authenticated Customers)\r\n     * this query will only return the Order within 2 hours of the Order being placed. This allows an Order confirmation\r\n     * screen to be shown immediately after completion of a guest checkout, yet prevents security risks of allowing\r\n     * general anonymous access to Order data.\r\n     */\r\n    orderByCode?: Maybe<Order>;\r\n    /** Get a Product either by id or slug. If neither 'id' nor 'slug' is specified, an error will result. */\r\n    product?: Maybe<Product>;\r\n    /** Get a list of Products */\r\n    products: ProductList;\r\n    /** Search Products based on the criteria set by the `SearchInput` */\r\n    search: SearchResponse;\r\n};\r\n\r\nexport type QueryCollectionsArgs = {\r\n    options?: Maybe<CollectionListOptions>;\r\n};\r\n\r\nexport type QueryCollectionArgs = {\r\n    id?: Maybe<Scalars['ID']>;\r\n    slug?: Maybe<Scalars['String']>;\r\n};\r\n\r\nexport type QueryFacetsArgs = {\r\n    options?: Maybe<FacetListOptions>;\r\n};\r\n\r\nexport type QueryFacetArgs = {\r\n    id: Scalars['ID'];\r\n};\r\n\r\nexport type QueryOrderArgs = {\r\n    id: Scalars['ID'];\r\n};\r\n\r\nexport type QueryOrderByCodeArgs = {\r\n    code: Scalars['String'];\r\n};\r\n\r\nexport type QueryProductArgs = {\r\n    id?: Maybe<Scalars['ID']>;\r\n    slug?: Maybe<Scalars['String']>;\r\n};\r\n\r\nexport type QueryProductsArgs = {\r\n    options?: Maybe<ProductListOptions>;\r\n};\r\n\r\nexport type QuerySearchArgs = {\r\n    input: SearchInput;\r\n};\r\n\r\nexport type RefreshCustomerVerificationResult = Success | NativeAuthStrategyError;\r\n\r\nexport type Refund = Node & {\r\n    __typename?: 'Refund';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    items: Scalars['Int'];\r\n    shipping: Scalars['Int'];\r\n    adjustment: Scalars['Int'];\r\n    total: Scalars['Int'];\r\n    method?: Maybe<Scalars['String']>;\r\n    state: Scalars['String'];\r\n    transactionId?: Maybe<Scalars['String']>;\r\n    reason?: Maybe<Scalars['String']>;\r\n    orderItems: Array<OrderItem>;\r\n    paymentId: Scalars['ID'];\r\n    metadata?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type RegisterCustomerAccountResult =\r\n    | Success\r\n    | MissingPasswordError\r\n    | PasswordValidationError\r\n    | NativeAuthStrategyError;\r\n\r\nexport type RegisterCustomerInput = {\r\n    emailAddress: Scalars['String'];\r\n    title?: Maybe<Scalars['String']>;\r\n    firstName?: Maybe<Scalars['String']>;\r\n    lastName?: Maybe<Scalars['String']>;\r\n    phoneNumber?: Maybe<Scalars['String']>;\r\n    password?: Maybe<Scalars['String']>;\r\n};\r\n\r\nexport type RelationCustomFieldConfig = CustomField & {\r\n    __typename?: 'RelationCustomFieldConfig';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    entity: Scalars['String'];\r\n    scalarFields: Array<Scalars['String']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type RemoveOrderItemsResult = Order | OrderModificationError;\r\n\r\nexport type RequestPasswordResetResult = Success | NativeAuthStrategyError;\r\n\r\nexport type RequestUpdateCustomerEmailAddressResult =\r\n    | Success\r\n    | InvalidCredentialsError\r\n    | EmailAddressConflictError\r\n    | NativeAuthStrategyError;\r\n\r\nexport type ResetPasswordResult =\r\n    | CurrentUser\r\n    | PasswordResetTokenInvalidError\r\n    | PasswordResetTokenExpiredError\r\n    | PasswordValidationError\r\n    | NativeAuthStrategyError\r\n    | NotVerifiedError;\r\n\r\nexport type Role = Node & {\r\n    __typename?: 'Role';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    code: Scalars['String'];\r\n    description: Scalars['String'];\r\n    permissions: Array<Permission>;\r\n    channels: Array<Channel>;\r\n};\r\n\r\nexport type RoleList = PaginatedList & {\r\n    __typename?: 'RoleList';\r\n    items: Array<Role>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type SearchInput = {\r\n    term?: Maybe<Scalars['String']>;\r\n    facetValueIds?: Maybe<Array<Scalars['ID']>>;\r\n    facetValueOperator?: Maybe<LogicalOperator>;\r\n    facetValueFilters?: Maybe<Array<FacetValueFilterInput>>;\r\n    collectionId?: Maybe<Scalars['ID']>;\r\n    collectionSlug?: Maybe<Scalars['String']>;\r\n    groupByProduct?: Maybe<Scalars['Boolean']>;\r\n    take?: Maybe<Scalars['Int']>;\r\n    skip?: Maybe<Scalars['Int']>;\r\n    sort?: Maybe<SearchResultSortParameter>;\r\n};\r\n\r\nexport type SearchReindexResponse = {\r\n    __typename?: 'SearchReindexResponse';\r\n    success: Scalars['Boolean'];\r\n};\r\n\r\nexport type SearchResponse = {\r\n    __typename?: 'SearchResponse';\r\n    items: Array<SearchResult>;\r\n    totalItems: Scalars['Int'];\r\n    facetValues: Array<FacetValueResult>;\r\n    collections: Array<CollectionResult>;\r\n};\r\n\r\nexport type SearchResult = {\r\n    __typename?: 'SearchResult';\r\n    sku: Scalars['String'];\r\n    slug: Scalars['String'];\r\n    productId: Scalars['ID'];\r\n    productName: Scalars['String'];\r\n    productAsset?: Maybe<SearchResultAsset>;\r\n    productVariantId: Scalars['ID'];\r\n    productVariantName: Scalars['String'];\r\n    productVariantAsset?: Maybe<SearchResultAsset>;\r\n    price: SearchResultPrice;\r\n    priceWithTax: SearchResultPrice;\r\n    currencyCode: CurrencyCode;\r\n    description: Scalars['String'];\r\n    facetIds: Array<Scalars['ID']>;\r\n    facetValueIds: Array<Scalars['ID']>;\r\n    /** An array of ids of the Collections in which this result appears */\r\n    collectionIds: Array<Scalars['ID']>;\r\n    /** A relevance score for the result. Differs between database implementations */\r\n    score: Scalars['Float'];\r\n};\r\n\r\nexport type SearchResultAsset = {\r\n    __typename?: 'SearchResultAsset';\r\n    id: Scalars['ID'];\r\n    preview: Scalars['String'];\r\n    focalPoint?: Maybe<Coordinate>;\r\n};\r\n\r\n/** The price of a search result product, either as a range or as a single price */\r\nexport type SearchResultPrice = PriceRange | SinglePrice;\r\n\r\nexport type SearchResultSortParameter = {\r\n    name?: Maybe<SortOrder>;\r\n    price?: Maybe<SortOrder>;\r\n};\r\n\r\nexport type SetCustomerForOrderResult =\r\n    | Order\r\n    | AlreadyLoggedInError\r\n    | EmailAddressConflictError\r\n    | NoActiveOrderError;\r\n\r\nexport type SetOrderShippingMethodResult =\r\n    | Order\r\n    | OrderModificationError\r\n    | IneligibleShippingMethodError\r\n    | NoActiveOrderError;\r\n\r\nexport type ShippingLine = {\r\n    __typename?: 'ShippingLine';\r\n    shippingMethod: ShippingMethod;\r\n    price: Scalars['Int'];\r\n    priceWithTax: Scalars['Int'];\r\n    discountedPrice: Scalars['Int'];\r\n    discountedPriceWithTax: Scalars['Int'];\r\n    discounts: Array<Discount>;\r\n};\r\n\r\nexport type ShippingMethod = Node & {\r\n    __typename?: 'ShippingMethod';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    code: Scalars['String'];\r\n    name: Scalars['String'];\r\n    description: Scalars['String'];\r\n    fulfillmentHandlerCode: Scalars['String'];\r\n    checker: ConfigurableOperation;\r\n    calculator: ConfigurableOperation;\r\n    translations: Array<ShippingMethodTranslation>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type ShippingMethodList = PaginatedList & {\r\n    __typename?: 'ShippingMethodList';\r\n    items: Array<ShippingMethod>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type ShippingMethodQuote = {\r\n    __typename?: 'ShippingMethodQuote';\r\n    id: Scalars['ID'];\r\n    price: Scalars['Int'];\r\n    priceWithTax: Scalars['Int'];\r\n    code: Scalars['String'];\r\n    name: Scalars['String'];\r\n    description: Scalars['String'];\r\n    /** Any optional metadata returned by the ShippingCalculator in the ShippingCalculationResult */\r\n    metadata?: Maybe<Scalars['JSON']>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type ShippingMethodTranslation = {\r\n    __typename?: 'ShippingMethodTranslation';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    languageCode: LanguageCode;\r\n    name: Scalars['String'];\r\n    description: Scalars['String'];\r\n};\r\n\r\n/** The price value where the result has a single price */\r\nexport type SinglePrice = {\r\n    __typename?: 'SinglePrice';\r\n    value: Scalars['Int'];\r\n};\r\n\r\nexport enum SortOrder {\r\n    ASC = 'ASC',\r\n    DESC = 'DESC',\r\n}\r\n\r\nexport type StringCustomFieldConfig = CustomField & {\r\n    __typename?: 'StringCustomFieldConfig';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    length?: Maybe<Scalars['Int']>;\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    pattern?: Maybe<Scalars['String']>;\r\n    options?: Maybe<Array<StringFieldOption>>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type StringFieldOption = {\r\n    __typename?: 'StringFieldOption';\r\n    value: Scalars['String'];\r\n    label?: Maybe<Array<LocalizedString>>;\r\n};\r\n\r\n/** Operators for filtering on a list of String fields */\r\nexport type StringListOperators = {\r\n    inList: Scalars['String'];\r\n};\r\n\r\n/** Operators for filtering on a String field */\r\nexport type StringOperators = {\r\n    eq?: Maybe<Scalars['String']>;\r\n    notEq?: Maybe<Scalars['String']>;\r\n    contains?: Maybe<Scalars['String']>;\r\n    notContains?: Maybe<Scalars['String']>;\r\n    in?: Maybe<Array<Scalars['String']>>;\r\n    notIn?: Maybe<Array<Scalars['String']>>;\r\n    regex?: Maybe<Scalars['String']>;\r\n};\r\n\r\n/** Indicates that an operation succeeded, where we do not want to return any more specific information. */\r\nexport type Success = {\r\n    __typename?: 'Success';\r\n    success: Scalars['Boolean'];\r\n};\r\n\r\nexport type Surcharge = Node & {\r\n    __typename?: 'Surcharge';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    description: Scalars['String'];\r\n    sku?: Maybe<Scalars['String']>;\r\n    taxLines: Array<TaxLine>;\r\n    price: Scalars['Int'];\r\n    priceWithTax: Scalars['Int'];\r\n    taxRate: Scalars['Float'];\r\n};\r\n\r\nexport type Tag = Node & {\r\n    __typename?: 'Tag';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    value: Scalars['String'];\r\n};\r\n\r\nexport type TagList = PaginatedList & {\r\n    __typename?: 'TagList';\r\n    items: Array<Tag>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type TaxCategory = Node & {\r\n    __typename?: 'TaxCategory';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    name: Scalars['String'];\r\n    isDefault: Scalars['Boolean'];\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type TaxLine = {\r\n    __typename?: 'TaxLine';\r\n    description: Scalars['String'];\r\n    taxRate: Scalars['Float'];\r\n};\r\n\r\nexport type TaxRate = Node & {\r\n    __typename?: 'TaxRate';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    name: Scalars['String'];\r\n    enabled: Scalars['Boolean'];\r\n    value: Scalars['Float'];\r\n    category: TaxCategory;\r\n    zone: Zone;\r\n    customerGroup?: Maybe<CustomerGroup>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type TaxRateList = PaginatedList & {\r\n    __typename?: 'TaxRateList';\r\n    items: Array<TaxRate>;\r\n    totalItems: Scalars['Int'];\r\n};\r\n\r\nexport type TextCustomFieldConfig = CustomField & {\r\n    __typename?: 'TextCustomFieldConfig';\r\n    name: Scalars['String'];\r\n    type: Scalars['String'];\r\n    list: Scalars['Boolean'];\r\n    label?: Maybe<Array<LocalizedString>>;\r\n    description?: Maybe<Array<LocalizedString>>;\r\n    readonly?: Maybe<Scalars['Boolean']>;\r\n    internal?: Maybe<Scalars['Boolean']>;\r\n    nullable?: Maybe<Scalars['Boolean']>;\r\n    ui?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type TransitionOrderToStateResult = Order | OrderStateTransitionError;\r\n\r\nexport type UpdateAddressInput = {\r\n    id: Scalars['ID'];\r\n    fullName?: Maybe<Scalars['String']>;\r\n    company?: Maybe<Scalars['String']>;\r\n    streetLine1?: Maybe<Scalars['String']>;\r\n    streetLine2?: Maybe<Scalars['String']>;\r\n    city?: Maybe<Scalars['String']>;\r\n    province?: Maybe<Scalars['String']>;\r\n    postalCode?: Maybe<Scalars['String']>;\r\n    countryCode?: Maybe<Scalars['String']>;\r\n    phoneNumber?: Maybe<Scalars['String']>;\r\n    defaultShippingAddress?: Maybe<Scalars['Boolean']>;\r\n    defaultBillingAddress?: Maybe<Scalars['Boolean']>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type UpdateCustomerEmailAddressResult =\r\n    | Success\r\n    | IdentifierChangeTokenInvalidError\r\n    | IdentifierChangeTokenExpiredError\r\n    | NativeAuthStrategyError;\r\n\r\nexport type UpdateCustomerInput = {\r\n    title?: Maybe<Scalars['String']>;\r\n    firstName?: Maybe<Scalars['String']>;\r\n    lastName?: Maybe<Scalars['String']>;\r\n    phoneNumber?: Maybe<Scalars['String']>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type UpdateCustomerPasswordResult =\r\n    | Success\r\n    | InvalidCredentialsError\r\n    | PasswordValidationError\r\n    | NativeAuthStrategyError;\r\n\r\nexport type UpdateOrderInput = {\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\nexport type UpdateOrderItemsResult =\r\n    | Order\r\n    | OrderModificationError\r\n    | OrderLimitError\r\n    | NegativeQuantityError\r\n    | InsufficientStockError;\r\n\r\nexport type User = Node & {\r\n    __typename?: 'User';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    identifier: Scalars['String'];\r\n    verified: Scalars['Boolean'];\r\n    roles: Array<Role>;\r\n    lastLogin?: Maybe<Scalars['DateTime']>;\r\n    authenticationMethods: Array<AuthenticationMethod>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n\r\n/**\r\n * Returned if the verification token (used to verify a Customer's email address) is valid, but has\r\n * expired according to the `verificationTokenDuration` setting in the AuthOptions.\r\n */\r\nexport type VerificationTokenExpiredError = ErrorResult & {\r\n    __typename?: 'VerificationTokenExpiredError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\n/**\r\n * Returned if the verification token (used to verify a Customer's email address) is either\r\n * invalid or does not match any expected tokens.\r\n */\r\nexport type VerificationTokenInvalidError = ErrorResult & {\r\n    __typename?: 'VerificationTokenInvalidError';\r\n    errorCode: ErrorCode;\r\n    message: Scalars['String'];\r\n};\r\n\r\nexport type VerifyCustomerAccountResult =\r\n    | CurrentUser\r\n    | VerificationTokenInvalidError\r\n    | VerificationTokenExpiredError\r\n    | MissingPasswordError\r\n    | PasswordValidationError\r\n    | PasswordAlreadySetError\r\n    | NativeAuthStrategyError;\r\n\r\nexport type Zone = Node & {\r\n    __typename?: 'Zone';\r\n    id: Scalars['ID'];\r\n    createdAt: Scalars['DateTime'];\r\n    updatedAt: Scalars['DateTime'];\r\n    name: Scalars['String'];\r\n    members: Array<Country>;\r\n    customFields?: Maybe<Scalars['JSON']>;\r\n};\r\n"]}