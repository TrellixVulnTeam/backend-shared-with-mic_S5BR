{"version":3,"mappings":"qLAEO,iBACP,WACA,MACA,mCACAA,WAEA,UACA,2BAGA,QACAC,iBACAC,mBACAA,eAEAC,UACA,4DAGA,gBAAuCC,IACvCH,mBACAI,SACAH,mBACAA,eACAA,kBACA,iBACAA,yBACA,YAAwBI,IAASA,IACjCJ,uBAEA,YAAwBI,IAASA,KACjC,WACAJ,UAAqB,OAAiBA,mBAGtCK,kBACAL,iBACA,uBACA,eACA,sBACA,OACAM,eAIAC,kBAEAC,SACA,8BACA,2BACAR,aACAA,oBAGAA,0BAIAS,eACA,MACA,IACAX,mCAEAY,GAEA,YADAV,0BAGAA,2DChEAW,aAAgCC,EAAeC,EAAgB,KAC3D,OAAQD,GAAS,IACZE,UAAU,OACVC,QAAQ,mBAAoB,IAC5BC,cACAD,QAAQ,yDAA0C,IAClDA,QAAQ,OAAQF,oCCHzBF,aAA0BC,EAAUC,GAChC,OAAa,MAATA,EACOI,MAAMC,KAAK,IAAIC,IAAIP,IAGnB,IAAI,IAAIQ,IAAIR,EAAIS,IAAIC,GAAQ,CAACA,EAAKT,GAAQS,KAAQC","names":["e","constructor","this","call","a","super","n","notifyNext","o","notifyComplete","_next","_tryProject","s","r","u","l","normalize","replace","toLowerCase","Array","from","Set","Map","map","_","values"],"sources":["webpack:///node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js","webpack:///common/src/normalize-string.ts","webpack:///common/src/unique.ts"],"sourcesContent":["import { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function withLatestFrom(...args) {\n    return (source) => {\n        let project;\n        if (typeof args[args.length - 1] === 'function') {\n            project = args.pop();\n        }\n        const observables = args;\n        return source.lift(new WithLatestFromOperator(observables, project));\n    };\n}\nclass WithLatestFromOperator {\n    constructor(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    }\n}\nclass WithLatestFromSubscriber extends OuterSubscriber {\n    constructor(destination, observables, project) {\n        super(destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        const len = observables.length;\n        this.values = new Array(len);\n        for (let i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (let i = 0; i < len; i++) {\n            let observable = observables[i];\n            this.add(subscribeToResult(this, observable, undefined, i));\n        }\n    }\n    notifyNext(_outerValue, innerValue, outerIndex) {\n        this.values[outerIndex] = innerValue;\n        const toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            const found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    }\n    notifyComplete() {\n    }\n    _next(value) {\n        if (this.toRespond.length === 0) {\n            const args = [value, ...this.values];\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    }\n    _tryProject(args) {\n        let result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    }\n}\n","/**\n * Normalizes a string to replace non-alphanumeric and diacritical marks with\n * plain equivalents.\n * Based on https://stackoverflow.com/a/37511463/772859\n */\nexport function normalizeString(input: string, spaceReplacer = ' '): string {\n    return (input || '')\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '')\n        .toLowerCase()\n        .replace(/[!\"£$%^&*()+[\\]{};:@#~?\\\\/,|><`¬'=‘’]/g, '')\n        .replace(/\\s+/g, spaceReplacer);\n}\n","/**\r\n * @description\r\n * Returns an array with only unique values. Objects are compared by reference,\r\n * unless the `byKey` argument is supplied, in which case matching properties will\r\n * be used to check duplicates\r\n */\r\nimport { isObject } from './shared-utils';\r\n\r\nexport function unique<T>(arr: T[], byKey?: keyof T): T[] {\r\n    if (byKey == null) {\r\n        return Array.from(new Set(arr));\r\n    } else {\r\n        // Based on https://stackoverflow.com/a/58429784/772859\r\n        return [...new Map(arr.map(item => [item[byKey], item])).values()];\r\n    }\r\n}\r\n"]}